<!DOCTYPE html>
<html data-html-server-rendered="true" lang="en" data-vue-tag="%7B%22lang%22:%7B%22ssr%22:%22en%22%7D%7D">
  <head>
    <title>msaschool - msaschool</title><meta name="gridsome:hash" content="df7767605291944c496eda034b7e8888219b734f"><meta data-vue-tag="ssr" charset="utf-8"><meta data-vue-tag="ssr" name="generator" content="Gridsome v0.7.22"><meta data-vue-tag="ssr" data-key="viewport" name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"><meta data-vue-tag="ssr" data-key="format-detection" name="format-detection" content="telephone=no"><meta data-vue-tag="ssr" data-key="og:type" name="og:type" content="website"><meta data-vue-tag="ssr" data-key="twitter:card" name="twitter:card" content="summary_large_image"><meta data-vue-tag="ssr" data-key="og:image" name="og:image" content="undefined/logo.jpg"><meta data-vue-tag="ssr" data-key="twitter:image" name="twitter:image" content="undefined/logo.jpg"><link data-vue-tag="ssr" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@mdi/font@latest/css/materialdesignicons.min.css"><link data-vue-tag="ssr" rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900"><link rel="preload" href="/assets/css/styles.styles.57498294.css" as="style"><link rel="preload" href="/assets/js/app.3663d38e.js" as="script"><link rel="preload" href="/assets/js/page--src--templates--vue-page-vue.bf23a17a.js" as="script"><link rel="prefetch" href="/assets/js/page--src--pages--404-vue.d8774f91.js"><link rel="prefetch" href="/assets/js/page--src--pages--index-vue.c5cc1104.js"><link rel="prefetch" href="/assets/js/search.d10d922c.js"><link rel="stylesheet" href="/assets/css/styles.styles.57498294.css"><style data-vue-tag="vuetify" type="text/css" id="vuetify-theme-stylesheet" nonce="undefined">.v-application a { color: #1976d2; }
.v-application .primary {
  background-color: #1976d2 !important;
  border-color: #1976d2 !important;
}
.v-application .primary--text {
  color: #1976d2 !important;
  caret-color: #1976d2 !important;
}
.v-application .primary.lighten-5 {
  background-color: #c7fdff !important;
  border-color: #c7fdff !important;
}
.v-application .primary--text.text--lighten-5 {
  color: #c7fdff !important;
  caret-color: #c7fdff !important;
}
.v-application .primary.lighten-4 {
  background-color: #a8e0ff !important;
  border-color: #a8e0ff !important;
}
.v-application .primary--text.text--lighten-4 {
  color: #a8e0ff !important;
  caret-color: #a8e0ff !important;
}
.v-application .primary.lighten-3 {
  background-color: #8ac5ff !important;
  border-color: #8ac5ff !important;
}
.v-application .primary--text.text--lighten-3 {
  color: #8ac5ff !important;
  caret-color: #8ac5ff !important;
}
.v-application .primary.lighten-2 {
  background-color: #6aaaff !important;
  border-color: #6aaaff !important;
}
.v-application .primary--text.text--lighten-2 {
  color: #6aaaff !important;
  caret-color: #6aaaff !important;
}
.v-application .primary.lighten-1 {
  background-color: #488fef !important;
  border-color: #488fef !important;
}
.v-application .primary--text.text--lighten-1 {
  color: #488fef !important;
  caret-color: #488fef !important;
}
.v-application .primary.darken-1 {
  background-color: #005eb6 !important;
  border-color: #005eb6 !important;
}
.v-application .primary--text.text--darken-1 {
  color: #005eb6 !important;
  caret-color: #005eb6 !important;
}
.v-application .primary.darken-2 {
  background-color: #00479b !important;
  border-color: #00479b !important;
}
.v-application .primary--text.text--darken-2 {
  color: #00479b !important;
  caret-color: #00479b !important;
}
.v-application .primary.darken-3 {
  background-color: #003180 !important;
  border-color: #003180 !important;
}
.v-application .primary--text.text--darken-3 {
  color: #003180 !important;
  caret-color: #003180 !important;
}
.v-application .primary.darken-4 {
  background-color: #001e67 !important;
  border-color: #001e67 !important;
}
.v-application .primary--text.text--darken-4 {
  color: #001e67 !important;
  caret-color: #001e67 !important;
}
.v-application .secondary {
  background-color: #424242 !important;
  border-color: #424242 !important;
}
.v-application .secondary--text {
  color: #424242 !important;
  caret-color: #424242 !important;
}
.v-application .secondary.lighten-5 {
  background-color: #c1c1c1 !important;
  border-color: #c1c1c1 !important;
}
.v-application .secondary--text.text--lighten-5 {
  color: #c1c1c1 !important;
  caret-color: #c1c1c1 !important;
}
.v-application .secondary.lighten-4 {
  background-color: #a6a6a6 !important;
  border-color: #a6a6a6 !important;
}
.v-application .secondary--text.text--lighten-4 {
  color: #a6a6a6 !important;
  caret-color: #a6a6a6 !important;
}
.v-application .secondary.lighten-3 {
  background-color: #8b8b8b !important;
  border-color: #8b8b8b !important;
}
.v-application .secondary--text.text--lighten-3 {
  color: #8b8b8b !important;
  caret-color: #8b8b8b !important;
}
.v-application .secondary.lighten-2 {
  background-color: #727272 !important;
  border-color: #727272 !important;
}
.v-application .secondary--text.text--lighten-2 {
  color: #727272 !important;
  caret-color: #727272 !important;
}
.v-application .secondary.lighten-1 {
  background-color: #595959 !important;
  border-color: #595959 !important;
}
.v-application .secondary--text.text--lighten-1 {
  color: #595959 !important;
  caret-color: #595959 !important;
}
.v-application .secondary.darken-1 {
  background-color: #2c2c2c !important;
  border-color: #2c2c2c !important;
}
.v-application .secondary--text.text--darken-1 {
  color: #2c2c2c !important;
  caret-color: #2c2c2c !important;
}
.v-application .secondary.darken-2 {
  background-color: #171717 !important;
  border-color: #171717 !important;
}
.v-application .secondary--text.text--darken-2 {
  color: #171717 !important;
  caret-color: #171717 !important;
}
.v-application .secondary.darken-3 {
  background-color: #000000 !important;
  border-color: #000000 !important;
}
.v-application .secondary--text.text--darken-3 {
  color: #000000 !important;
  caret-color: #000000 !important;
}
.v-application .secondary.darken-4 {
  background-color: #000000 !important;
  border-color: #000000 !important;
}
.v-application .secondary--text.text--darken-4 {
  color: #000000 !important;
  caret-color: #000000 !important;
}
.v-application .accent {
  background-color: #82b1ff !important;
  border-color: #82b1ff !important;
}
.v-application .accent--text {
  color: #82b1ff !important;
  caret-color: #82b1ff !important;
}
.v-application .accent.lighten-5 {
  background-color: #ffffff !important;
  border-color: #ffffff !important;
}
.v-application .accent--text.text--lighten-5 {
  color: #ffffff !important;
  caret-color: #ffffff !important;
}
.v-application .accent.lighten-4 {
  background-color: #f8ffff !important;
  border-color: #f8ffff !important;
}
.v-application .accent--text.text--lighten-4 {
  color: #f8ffff !important;
  caret-color: #f8ffff !important;
}
.v-application .accent.lighten-3 {
  background-color: #daffff !important;
  border-color: #daffff !important;
}
.v-application .accent--text.text--lighten-3 {
  color: #daffff !important;
  caret-color: #daffff !important;
}
.v-application .accent.lighten-2 {
  background-color: #bce8ff !important;
  border-color: #bce8ff !important;
}
.v-application .accent--text.text--lighten-2 {
  color: #bce8ff !important;
  caret-color: #bce8ff !important;
}
.v-application .accent.lighten-1 {
  background-color: #9fccff !important;
  border-color: #9fccff !important;
}
.v-application .accent--text.text--lighten-1 {
  color: #9fccff !important;
  caret-color: #9fccff !important;
}
.v-application .accent.darken-1 {
  background-color: #6596e2 !important;
  border-color: #6596e2 !important;
}
.v-application .accent--text.text--darken-1 {
  color: #6596e2 !important;
  caret-color: #6596e2 !important;
}
.v-application .accent.darken-2 {
  background-color: #467dc6 !important;
  border-color: #467dc6 !important;
}
.v-application .accent--text.text--darken-2 {
  color: #467dc6 !important;
  caret-color: #467dc6 !important;
}
.v-application .accent.darken-3 {
  background-color: #2364aa !important;
  border-color: #2364aa !important;
}
.v-application .accent--text.text--darken-3 {
  color: #2364aa !important;
  caret-color: #2364aa !important;
}
.v-application .accent.darken-4 {
  background-color: #004c90 !important;
  border-color: #004c90 !important;
}
.v-application .accent--text.text--darken-4 {
  color: #004c90 !important;
  caret-color: #004c90 !important;
}
.v-application .error {
  background-color: #ff5252 !important;
  border-color: #ff5252 !important;
}
.v-application .error--text {
  color: #ff5252 !important;
  caret-color: #ff5252 !important;
}
.v-application .error.lighten-5 {
  background-color: #ffe4d5 !important;
  border-color: #ffe4d5 !important;
}
.v-application .error--text.text--lighten-5 {
  color: #ffe4d5 !important;
  caret-color: #ffe4d5 !important;
}
.v-application .error.lighten-4 {
  background-color: #ffc6b9 !important;
  border-color: #ffc6b9 !important;
}
.v-application .error--text.text--lighten-4 {
  color: #ffc6b9 !important;
  caret-color: #ffc6b9 !important;
}
.v-application .error.lighten-3 {
  background-color: #ffa99e !important;
  border-color: #ffa99e !important;
}
.v-application .error--text.text--lighten-3 {
  color: #ffa99e !important;
  caret-color: #ffa99e !important;
}
.v-application .error.lighten-2 {
  background-color: #ff8c84 !important;
  border-color: #ff8c84 !important;
}
.v-application .error--text.text--lighten-2 {
  color: #ff8c84 !important;
  caret-color: #ff8c84 !important;
}
.v-application .error.lighten-1 {
  background-color: #ff6f6a !important;
  border-color: #ff6f6a !important;
}
.v-application .error--text.text--lighten-1 {
  color: #ff6f6a !important;
  caret-color: #ff6f6a !important;
}
.v-application .error.darken-1 {
  background-color: #df323b !important;
  border-color: #df323b !important;
}
.v-application .error--text.text--darken-1 {
  color: #df323b !important;
  caret-color: #df323b !important;
}
.v-application .error.darken-2 {
  background-color: #bf0025 !important;
  border-color: #bf0025 !important;
}
.v-application .error--text.text--darken-2 {
  color: #bf0025 !important;
  caret-color: #bf0025 !important;
}
.v-application .error.darken-3 {
  background-color: #9f0010 !important;
  border-color: #9f0010 !important;
}
.v-application .error--text.text--darken-3 {
  color: #9f0010 !important;
  caret-color: #9f0010 !important;
}
.v-application .error.darken-4 {
  background-color: #800000 !important;
  border-color: #800000 !important;
}
.v-application .error--text.text--darken-4 {
  color: #800000 !important;
  caret-color: #800000 !important;
}
.v-application .info {
  background-color: #2196f3 !important;
  border-color: #2196f3 !important;
}
.v-application .info--text {
  color: #2196f3 !important;
  caret-color: #2196f3 !important;
}
.v-application .info.lighten-5 {
  background-color: #d4ffff !important;
  border-color: #d4ffff !important;
}
.v-application .info--text.text--lighten-5 {
  color: #d4ffff !important;
  caret-color: #d4ffff !important;
}
.v-application .info.lighten-4 {
  background-color: #b5ffff !important;
  border-color: #b5ffff !important;
}
.v-application .info--text.text--lighten-4 {
  color: #b5ffff !important;
  caret-color: #b5ffff !important;
}
.v-application .info.lighten-3 {
  background-color: #95e8ff !important;
  border-color: #95e8ff !important;
}
.v-application .info--text.text--lighten-3 {
  color: #95e8ff !important;
  caret-color: #95e8ff !important;
}
.v-application .info.lighten-2 {
  background-color: #75ccff !important;
  border-color: #75ccff !important;
}
.v-application .info--text.text--lighten-2 {
  color: #75ccff !important;
  caret-color: #75ccff !important;
}
.v-application .info.lighten-1 {
  background-color: #51b0ff !important;
  border-color: #51b0ff !important;
}
.v-application .info--text.text--lighten-1 {
  color: #51b0ff !important;
  caret-color: #51b0ff !important;
}
.v-application .info.darken-1 {
  background-color: #007cd6 !important;
  border-color: #007cd6 !important;
}
.v-application .info--text.text--darken-1 {
  color: #007cd6 !important;
  caret-color: #007cd6 !important;
}
.v-application .info.darken-2 {
  background-color: #0064ba !important;
  border-color: #0064ba !important;
}
.v-application .info--text.text--darken-2 {
  color: #0064ba !important;
  caret-color: #0064ba !important;
}
.v-application .info.darken-3 {
  background-color: #004d9f !important;
  border-color: #004d9f !important;
}
.v-application .info--text.text--darken-3 {
  color: #004d9f !important;
  caret-color: #004d9f !important;
}
.v-application .info.darken-4 {
  background-color: #003784 !important;
  border-color: #003784 !important;
}
.v-application .info--text.text--darken-4 {
  color: #003784 !important;
  caret-color: #003784 !important;
}
.v-application .success {
  background-color: #4caf50 !important;
  border-color: #4caf50 !important;
}
.v-application .success--text {
  color: #4caf50 !important;
  caret-color: #4caf50 !important;
}
.v-application .success.lighten-5 {
  background-color: #dcffd6 !important;
  border-color: #dcffd6 !important;
}
.v-application .success--text.text--lighten-5 {
  color: #dcffd6 !important;
  caret-color: #dcffd6 !important;
}
.v-application .success.lighten-4 {
  background-color: #beffba !important;
  border-color: #beffba !important;
}
.v-application .success--text.text--lighten-4 {
  color: #beffba !important;
  caret-color: #beffba !important;
}
.v-application .success.lighten-3 {
  background-color: #a2ff9e !important;
  border-color: #a2ff9e !important;
}
.v-application .success--text.text--lighten-3 {
  color: #a2ff9e !important;
  caret-color: #a2ff9e !important;
}
.v-application .success.lighten-2 {
  background-color: #85e783 !important;
  border-color: #85e783 !important;
}
.v-application .success--text.text--lighten-2 {
  color: #85e783 !important;
  caret-color: #85e783 !important;
}
.v-application .success.lighten-1 {
  background-color: #69cb69 !important;
  border-color: #69cb69 !important;
}
.v-application .success--text.text--lighten-1 {
  color: #69cb69 !important;
  caret-color: #69cb69 !important;
}
.v-application .success.darken-1 {
  background-color: #2d9437 !important;
  border-color: #2d9437 !important;
}
.v-application .success--text.text--darken-1 {
  color: #2d9437 !important;
  caret-color: #2d9437 !important;
}
.v-application .success.darken-2 {
  background-color: #00791e !important;
  border-color: #00791e !important;
}
.v-application .success--text.text--darken-2 {
  color: #00791e !important;
  caret-color: #00791e !important;
}
.v-application .success.darken-3 {
  background-color: #006000 !important;
  border-color: #006000 !important;
}
.v-application .success--text.text--darken-3 {
  color: #006000 !important;
  caret-color: #006000 !important;
}
.v-application .success.darken-4 {
  background-color: #004700 !important;
  border-color: #004700 !important;
}
.v-application .success--text.text--darken-4 {
  color: #004700 !important;
  caret-color: #004700 !important;
}
.v-application .warning {
  background-color: #fb8c00 !important;
  border-color: #fb8c00 !important;
}
.v-application .warning--text {
  color: #fb8c00 !important;
  caret-color: #fb8c00 !important;
}
.v-application .warning.lighten-5 {
  background-color: #ffff9e !important;
  border-color: #ffff9e !important;
}
.v-application .warning--text.text--lighten-5 {
  color: #ffff9e !important;
  caret-color: #ffff9e !important;
}
.v-application .warning.lighten-4 {
  background-color: #fffb82 !important;
  border-color: #fffb82 !important;
}
.v-application .warning--text.text--lighten-4 {
  color: #fffb82 !important;
  caret-color: #fffb82 !important;
}
.v-application .warning.lighten-3 {
  background-color: #ffdf67 !important;
  border-color: #ffdf67 !important;
}
.v-application .warning--text.text--lighten-3 {
  color: #ffdf67 !important;
  caret-color: #ffdf67 !important;
}
.v-application .warning.lighten-2 {
  background-color: #ffc24b !important;
  border-color: #ffc24b !important;
}
.v-application .warning--text.text--lighten-2 {
  color: #ffc24b !important;
  caret-color: #ffc24b !important;
}
.v-application .warning.lighten-1 {
  background-color: #ffa72d !important;
  border-color: #ffa72d !important;
}
.v-application .warning--text.text--lighten-1 {
  color: #ffa72d !important;
  caret-color: #ffa72d !important;
}
.v-application .warning.darken-1 {
  background-color: #db7200 !important;
  border-color: #db7200 !important;
}
.v-application .warning--text.text--darken-1 {
  color: #db7200 !important;
  caret-color: #db7200 !important;
}
.v-application .warning.darken-2 {
  background-color: #bb5900 !important;
  border-color: #bb5900 !important;
}
.v-application .warning--text.text--darken-2 {
  color: #bb5900 !important;
  caret-color: #bb5900 !important;
}
.v-application .warning.darken-3 {
  background-color: #9d4000 !important;
  border-color: #9d4000 !important;
}
.v-application .warning--text.text--darken-3 {
  color: #9d4000 !important;
  caret-color: #9d4000 !important;
}
.v-application .warning.darken-4 {
  background-color: #802700 !important;
  border-color: #802700 !important;
}
.v-application .warning--text.text--darken-4 {
  color: #802700 !important;
  caret-color: #802700 !important;
}</style><noscript data-vue-tag="ssr"><style>.g-image--loading{display:none;}</style></noscript>
  </head>
  <body >
    <div data-server-rendered="true" id="app" class="font-sans antialiased text-ui-typo bg-ui-background"><div class="flex flex-col justify-start min-h-screen"><header class="top-0 z-10 border-b bg-ui-background border-ui-border" style="position:fixed;width:100%;"><div class="py-2 border-t-2 border-ui-primary"><div><div class="flex item-center justify-center"><div class="flex flex-col items-center  sm:flex-row" style="margin-left:5%; place-self:center; "><a href="/operation/introduction/" title="Home" style="margin-right:30px;"><svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="80%" height="100%" viewBox="0 0 310 72" enable-background="new 0 0 310 72" xml:space="preserve" style="margin-right:20px;margin-left:10px;"><image id="image0" x="0" y="0" xlink:href="data:image/png;base64,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" style="object-fit: fill; width:300px; height:80px;"></image></svg></a><!----></div><div class="flex flex-col items-center px-3   mr-auto  sm:flex-row" style="justify-content:flex-end;margin-right:5%;"></div></div></div></div></header><main class="container relative flex flex-wrap justify-start flex-1 w-full bg-ui-background"><!----><div style="max-width:90% !important;margin-top:3% !important;"><div class="flex flex-wrap items-start justify-start"><div class="order-1 w-full " style="width:90%;margin-left:5%;margin-right:2%;"><div><div class="content"><h2>실습 스크립트 - 컨테이너 오케스트레이션 Lab. Guide</h2>
<h3>구글 (Google) Cloud</h3>
<details>
<summary>Google Cloud Platform 기반의 Container Orchestration Lab. Scripts</summary>
<p>
<details>
  <summary><b>자주 사용되는 GCP Cloud 명령어</b></summary>
<ul>
<li>
<p><b>Referencing URL: <a href="https://cloud.google.com/kubernetes-engine/docs/how-to/managing-clusters?hl=ko">https://cloud.google.com/kubernetes-engine/docs/how-to/managing-clusters?hl=ko</a></b></p>
</li>
<li>
<p><b>GCP 인증</b></p>
<ul>
<li>gcloud init</li>
</ul>
</li>
<li>
<p><b>GCP 클러스터 생성</b></p>
<ul>
<li>gcloud container clusters create (Cluster Name) --zone asia-northeast1-a --enable-cloud-logging --enable-cloud-monitoring --subnetwork default</li>
</ul>
</li>
<li>
<p><b>GCP 클러스터 토큰 가져오기</b></p>
<ul>
<li>gcloud container clusters get-credentials (Cluster Name) --zone asia-northeast1-a --project (PROJECT-NAME)</li>
</ul>
</li>
<li>
<p><b>GCP GCR(Google Container Registry) 인증</b></p>
<ul>
<li>gcloud auth configure-docker</li>
</ul>
</li>
<li>
<p><b>GCR 레지스트리에 이미지 Push</b></p>
<ul>
<li>docker push <a href="http://gcr.io/PROJECT-NAME/IMAGE-NAME:v1">gcr.io/PROJECT-NAME/IMAGE-NAME:v1</a></li>
<li>(docker  version 18.03 이하)</li>
<li>gcloud docker --push <a href="http://gcr.io/PROJECT-NAME/IMAGE-NAME:v1">gcr.io/PROJECT-NAME/IMAGE-NAME:v1</a></li>
<li>오류(unknown flag: --password-stdin) 발생 시,
<ul>
<li>docker login --username AWS -p $(aws ecr get-login-password --region (Region-Code)) (Account-Id).dkr.ecr.(Region-Code).amazonaws.com/</li>
</ul>
</li>
</ul>
</li>
<li>
<p><b>GCP 클러스터 삭제</b></p>
<ul>
<li>gcloud container clusters delete [CLUSTER_NAME]</li>
</ul>
</li>
</ul>
</details> 
<h3>Docker</h3>
<details>
<summary><b>Docker Hands-on</b></summary>
<ul>
<li>
<p><b>Lab. image</b></p>
<ul>
<li>이미지 Pull
<ul>
<li>docker pull hello-world</li>
<li>docker images</li>
<li>docker pull nginx</li>
<li>docker pull nginx:latest</li>
<li>docker pull <a href="http://docker.io/library/nginx:latest">docker.io/library/nginx:latest</a></li>
<li>docker pull nginx:1.16.1</li>
<li>docker images</li>
</ul>
</li>
<li>도커허브 (Docker Hub, 가입)
<ul>
<li><a href="http://hub.docker.com">http://hub.docker.com</a> # 접속 후, nginx 검색</li>
</ul>
</li>
<li>이미지 Tagging
<ul>
<li>docker image tag nginx my-nginx # Create 태그</li>
</ul>
</li>
<li>이미지 삭제
<ul>
<li>docker image rm my-nginx</li>
<li>docker image rm hello-world</li>
<li>docker image rm $(docker images -q) # 한번에 모든 도커 이미지 지우기</li>
</ul>
</li>
</ul>
</li>
<li>
<p><b>Lab. container</b></p>
<ul>
<li>컨테이너 생성
<ul>
<li>docker run hello-world # 컨테이너 만들기</li>
<li>docker run --name hello hello-world # 이름 지정, 미지정시 임의의 이름으로 생성</li>
<li>docker run --name my-nginx -d -p 8080:80 nginx</li>
<li>docker ps</li>
</ul>
</li>
<li>컨테이너 시작/종료
<ul>
<li>docker stop my-nginx</li>
<li>docker start my-nginx</li>
</ul>
</li>
<li>컨테이너 포트 노출
<ul>
<li><a href="http://localhost">http://localhost</a> 에서 nginx index.html 확인</li>
<li>docker container rm my-nginx</li>
<li>docker run --name my-nginx -d -p 8080:80 nginx</li>
<li><a href="http://localhost:8080">http://localhost:8080</a> 에서 nginx index.html 확인</li>
</ul>
</li>
<li>컨테이너 접근
<ul>
<li>docker exec my-nginx cat /usr/share/nginx/html/index.html #실행 중 컨테이너 접근</li>
<li>docker exec -i -t  my-nginx /bin/bash
<ul>
<li>apt-get update</li>
<li>apt-get install curl</li>
<li>curl localhost</li>
<li>exit</li>
</ul>
</li>
</ul>
</li>
<li>컨테이너 삭제
<ul>
<li>docker container rm my-nginx # 실행 중 컨테이너  삭제 시, 오류</li>
<li>docker container rm $(docker ps -a -q) # 한번에 모든 컨테이너 지우기</li>
</ul>
</li>
</ul>
</li>
<li>
<p><b>Lab. Docker Build &amp; Push</b></p>
<ul>
<li>Dockerfile 로부터 이미지 생성
<ul>
<li>Dockerfile &amp; 리소스 생성
<ul>
<li>mkdir Dockerfile</li>
<li>cd Dockerfile</li>
<li>nano index.html<pre style="white-space: pre-wrap">"Hi~ My name is Park Yong Joo.."</pre>
</li>
<li>저장 및 종료 (Ctrl + X, y 입력 후 엔터)</li>
<li>nano Dockerfile<pre style="white-space: pre-wrap">
FROM nginx
COPY index.html /usr/share/nginx/html/
</pre>
</li>
<li>저장 및 종료 (Ctrl + x, Y 입력 후 엔터)</li>
</ul>
</li>
<li>도커라이징 &amp; Docker Hub에 Push
<ul>
<li>docker build -t (Docker-ID)/my-nginx .</li>
<li>docker images</li>
<li>docker push (Docker-ID)/my-nginx<br />
&quot;denied: 권한오류 생성 시, docker login 명령으로 Docker Hub에 로그인해 준다.&quot;</li>
</ul>
</li>
<li><a href="http://hub.docker.com">http://hub.docker.com</a> 에서 이미지 확인</li>
<li>Docker Hub 이미지로부터 컨테이너 실행
<ul>
<li>docker run --name new-nginx -d -p 8081:80 (Docker-ID)/my-nginx</li>
</ul>
</li>
<li>Browser에서 실행 애플리케이션 확인
<ul>
<li><a href="http://localhost:8081">http://localhost:8081</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><b>Clear</b></p>
<ul>
<li>docker container rm $(docker ps -a -q)
<ul>
<li>container 삭제 전, 실행 중인 컨테이너를 정지시켜 준다.</li>
<li>docker container stop new-nginx</li>
</ul>
</li>
<li>docker image rm -f $(docker images -q)</li>
</ul>
</li>
</ul>
</details> 
<h3>Kubernetes</h3>
<details>
<summary><b>Kubernetes Hands-on</b></summary>
<ul>
<li><b>Cloud Shell에서 Docker hub 토큰 생성 (docker hub의 접속정보 입력)</b>
<ul>
<li>docker login</li>
</ul>
</li>
<li><b>Kubernetes Hands-on</b>
<ul>
<li>
<p>Lab에 필요한 리소스 내려받기</p>
<ul>
<li>git clone <a href="https://github.com/acmexii/mall.git">https://github.com/acmexii/mall.git</a></li>
<li>git clone <a href="https://github.com/event-storming/container-orchestration.git">https://github.com/event-storming/container-orchestration.git</a></li>
<li>cd container-orchestration</li>
<li>cd yaml</li>
</ul>
</li>
<li>
<p>Lab. K8s Sample App 생성</p>
<ul>
<li>어플리케이션 생성/ 확인
<ul>
<li>Docker hub에 올린 이미지를 통한 컨테이너 생성<pre style="white-space: pre-wrap">kubectl create deploy my-nginx --image=apexacme/my-nginx:v1"</pre>
</li>
<li>클러스터 외부에 노출하기<pre style="white-space: pre-wrap">kubectl expose deploy my-nginx --type=LoadBalancer --port=80"</pre>
</li>
</ul>
</li>
<li>서비스 확인하기
<ul>
<li>kubectl get svc의 EXTERNAL-IP 복사</li>
<li>Browser에서 EXTERNAL-IP:80 접속</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Lab. Pod &amp; 기본명령</p>
<ul>
<li>kubectl get nodes
<ul>
<li>쿠버네티스에 제대로 접속했는지 확인</li>
<li>현 클러스터의 워크노드를 리스트업</li>
<li>접속 결과 안나오는 경우
<ul>
<li>kubectl config current-context 명령으로 Cluster 접속 확인</li>
</ul>
</li>
</ul>
</li>
<li>객체의 검색
<ul>
<li>kubectl get [object type]</li>
<li>kubectl get pods   # pods = pod = po</li>
<li>kubectl get deployments   # deploy</li>
<li>kubectl get services    # svc</li>
<li>kubectl get replicaset    # rs</li>
</ul>
</li>
<li>객체의 모니터링
<ul>
<li>watch kubectl get all</li>
<li>kubectl get pod -w</li>
<li>watch kubectl get pod</li>
</ul>
</li>
<li>객체의 유형
<ul>
<li>Service
<ul>
<li>types
<ul>
<li>LoadBalancer
<ul>
<li>클라우드 제공자에 의해 제공된 Loadbalancer 로 노출</li>
<li>front-end 혹은 ingress (api gateway)</li>
</ul>
</li>
<li>ClusterIP(default) / NodePort
<ul>
<li>클러스터 내부 IP</li>
<li>내부 마이크로 서비스</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Deployment
<ul>
<li>ReplicaSet (하나이상 생성)
<ul>
<li>Pod (하나이상 생성)
<ul>
<li>Container (docker ) 하나이상.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Pod</li>
<li>ReplicaSet</li>
<li>Ingress</li>
<li>Secret</li>
<li>ConfigMap</li>
<li>ServiceAccount = sa</li>
<li>statefulset</li>
<li>daemonset</li>
</ul>
</li>
<li>설정파일(YAML)을 통한 Pod 배포 (직접 타이핑)
<ul>
<li>nano declarative-pod.yaml<pre style="white-space: pre-wrap">
apiVersion: v1
kind: Pod
metadata:
  name: declarative-pod
  labels:
    env: test
spec:
  containers:
  - name: my-first-
    image: nginx
</pre>
</li>
<li>저장 및 종료 (ctrl + X, Y, 엔터)</li>
<li>kubectl create -f declarative-pod.yaml</li>
<li>kubectl get pods</li>
</ul>
</li>
<li>원하는 Node 타입에 Pod 생성
<ul>
<li>pwd 명령으로 현 위치가 /container-orchestration/yaml/pod 인지 확인</li>
<li>kubectl create -f pod-with-nodeselector.yaml</li>
<li>kubectl get po -o wide
<ul>
<li>Pod가 찾는 노드가 없어 pending 상태</li>
</ul>
</li>
<li>노드에 라벨 추가
<ul>
<li>kubectl label nodes [your-node-name] disktype=ssd</li>
<li>kubectl get nodes --show-labels | grep ssd</li>
</ul>
</li>
<li>kubectl get po -o wide</li>
</ul>
</li>
<li>생성된 Pod 및 오브젝트 삭제
<ul>
<li>kubectl delete pod [pod명]</li>
<li>kubectl delete service,deploy --all</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Lab. Label</p>
<ul>
<li>kubectl run nginx --image=nginx</li>
<li>kubectl get pods -l app=nginx</li>
<li>kubectl get pods --selector app=nginx</li>
<li>
<pre style="white-space: pre-wrap">kubectl get pods --selector "app in (nginx, test)"</pre>
</li>
</ul>
</li>
<li>
<p>Lab. ReplicaSet</p>
<ul>
<li>pwd 로 현 위치가 /container-orchestration/yaml/replicaset 인지 확인</li>
<li>kubectl create -f replicaset.yaml</li>
<li>kubectl get all</li>
<li>#replica 개수 조정
<ul>
<li>kubectl scale replicaset/frontend --replicas=5</li>
<li>kubectl get po</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Lab. Deployment &amp; 기본명령</p>
<ul>
<li>기본 nginx 서버의 배포</li>
<li>kubectl create deploy nginx --image=nginx</li>
<li>kubectl get deploy nginx</li>
<li>kubectl get replicaset -l app=nginx</li>
<li>kubectl get po -l app=nginx  # “-l” 옵션은 label의 key/value 로 객체를 필터링</li>
<li>kubectl get pods --selector app=nginx</li>
<li>
<pre style="white-space: pre-wrap">kubectl get pods --selector "app in (nginx, test)"</pre>
</li>
<li>kubectl describe po (검색한 pod name)</li>
<li>(pod 제거)</li>
<li>kubectl delete po --all   #</li>
<li>(pod 를 제거해도 재생됨을 확인)</li>
<li>kubectl get po</li>
<li>(scale out)</li>
<li>kubectl scale deploy nginx --replicas=3</li>
<li>kubectl get po   # pod 개수가 3개로 늘어남을 확인</li>
<li>kubectl delete po --all   # pod 를 모두 지움</li>
<li>kubectl get po   # pod 를 모두 지워도 결국 3개로 복원됨을 확인</li>
<li>( 제거하기 위해서는 deployment 를 제거해야만 함)</li>
<li>kubectl delete deploy nginx</li>
</ul>
</li>
<li>
<p>Lab. Rollout &amp; Back</p>
<ul>
<li>(pwd 로 현 위치가 /container-orchestration/yaml/ 인지 확인)</li>
<li>kubectl create -f nginx.yaml</li>
<li>(배포주석 확인, 주석이 없을 경우 아래 명령으로 주석 추가( Rollback시, 필요) )</li>
<li>
<pre style="white-space: pre-wrap">kubectl annotate deploy nginx-deployment kubernetes.io/change-cause="v1 is nginx:1.7.9"</pre>
</li>
<li>(설정의 변경)</li>
<li>파일을 편집기에서 열어(nano nginx.yaml) spec &gt; replicas 부분을 3–&gt;5 로 수정</li>
<li>kubectl apply -f nginx.yaml</li>
<li>(스케일 아웃 결과 확인)</li>
<li>kubectl get deploy     # DESIRED :3 --&gt; 5 로 수정되고 곧 ACTIVE 도 5가 됨</li>
<li>(무정지 버전업)</li>
<li>파일을 편집기에 열어서(nano nginx.yaml) spec &gt; template &gt; image 부분을 nginx:1.7.9 -&gt; nginx:1.9.1 로 수정</li>
<li>kubectl apply -f nginx.yaml</li>
<li>(배포주석 달기)</li>
<li>
<pre style="white-space: pre-wrap">kubectl annotate deploy nginx-deployment kubernetes.io/change-cause="v2 is nginx:1.9.1"</pre>
</li>
<li>(결과확인)</li>
<li>kubectl describe po &lt;해당 deployment 의 pod 중 하나의 이름&gt;    # 내용의 image 부분이 1.791 인지 확인</li>
<li>(무정지 재배포 히스토리 확인)</li>
<li>kubectl rollout history deploy nginx-deployment</li>
<li>(다음과 같이 출력됨을 확인)<br />
“REVISION  CHANGE-CAUSE<br />
1         v1 is nginx:1.7.9<br />
2         v2 is nginx:1.9.1”</li>
<li>(롤백하기)</li>
<li>kubectl rollout undo deploy nginx-deployment</li>
<li>kubectl rollout undo deployment nginx --to-revision 1</li>
</ul>
</li>
<li>
<p>Lab. Service</p>
<ul>
<li>kubectl delete service,deploy --all  # 기존 이력 삭제</li>
<li>(다시 생성)</li>
<li>kubectl create deploy nginx --image=nginx</li>
<li>(서비스로 노출)</li>
<li>
<pre style="white-space: pre-wrap">kubectl expose deploy nginx --type="LoadBalancer" --port=80</pre>
</li>
<li>(웹 브라우저를 열고 생성된 external ip 로 접속, Nginx welcome 메시지 확인)</li>
<li>kubectl exec -it (pod name) --/bin/bash   # 생성된 nginx 서버 linux 의 shell 에 접근</li>
</ul>
</li>
<li>
<p>Auto Scale-Out</p>
<ul>
<li>pwd 로 현 위치가 /container-orchestration/yaml/ 인지 확인</li>
<li>(모든 객체 지우기)</li>
<li>kubectl delete deploy,service,pod --all</li>
<li>(대상 서비스 배포 및 모니터링)</li>
<li>kubectl apply -f <a href="https://k8s.io/examples/application/php-apache.yaml">https://k8s.io/examples/application/php-apache.yaml</a>
<ul>
<li>NOTE : 서비스가 Auto Scaling되기 위해서는 컨테이너 Spec에 Resources : 설정이 있어야 함<br />
&quot; resources:<br />
limits:<br />
cpu: 500m<br />
requests:<br />
cpu: 200m&quot;</li>
</ul>
</li>
<li>(오토 스케일링 설정, hpa: HorizontalPodAutoscaler )
<ul>
<li>kubectl autoscale deployment php-apache --cpu-percent=20 --min=1 --max=10<br />
cpu-percent=50 : Pod 들의 요청 대비 평균 CPU 사용율 (여기서는  요청이 200 milli-cores이므로, 모든 Pod의 평균 CPU 사용율이 100 milli-cores(50%)를 넘게되면 HPA 발생)&quot;</li>
<li>kubectl get hpa php-apache -o yaml</li>
</ul>
</li>
<li>로드 제너레이터(siege)가 설치된 컨테이너 생성
<ul>
<li>cat siege.yaml</li>
<li>kubectl create -f siege.yaml</li>
</ul>
</li>
<li>로드 생성
<ul>
<li>siege -c30 -t30S -v http://php-apache</li>
</ul>
</li>
<li>(오토 스케일링이 되지 않을 때 :  kubectl get hpa의 TARGETS 부분에 cpu 사용률이 <unknown>으로 출력될 때)
<ul>
<li>metrics-server가 제대로 실행중인지 kubectl top pods 명령으로 포드 cpu 사용률이 모니터링 되는지 확인</li>
<li>디플로이먼트의 컨테이너 옵션에 cpu request 옵션이 제대로 걸려 있는지 확인</li>
<li>cpu request옵션이 없으면 hpa가 cpu사용량에 필요한 계산을 할 수 없음</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Lab. Volume</p>
<ul>
<li>(pwd 로 현 위치가 /container-orchestration/yaml/volume 인지 확인)</li>
<li>(emptyDir 마운트)</li>
<li>kubectl create -f volume-emptydir.yaml
<ul>
<li>kubectl exec -it shared-volumes --container redis --/bin/bash</li>
<li>cd /data/shared</li>
<li>echo test… &gt; test.txt</li>
<li>exit</li>
<li>kubectl exec -it shared-volumes --container nginx --/bin/bash</li>
<li>cd /data/shared</li>
<li>ls</li>
</ul>
</li>
<li>(GitRepository를 볼륨으로 마운트)</li>
<li>kubectl create -f volume-gitrepo.yaml</li>
<li>(PersistentVolumeClaim 생성)</li>
<li>kubectl create -f volume-pvc.yaml</li>
<li>kubectl get pvc</li>
<li>kubectl describe pvc azure-managed-disk</li>
<li>(생성된 PersistentVolueClaim으로 Pod 생성하기)</li>
<li>kubectl create -f pod-with-pvc.yaml</li>
<li>kubectl describe pod mypod</li>
<li>(포드 접속)</li>
<li>kubectl exec -it mypod --/bin/bash</li>
<li>(마운트 및 사이즈 확인)</li>
<li>df -k</li>
</ul>
</li>
<li>
<p>Lab. ConfigMap</p>
<ul>
<li>(pwd 로 현 위치가 /container-orchestration/yaml/configmap/ 인지 확인)</li>
<li>(컨피그 맵 생성)</li>
<li>kubectl create configmap hello-cm --from-literal=language=java</li>
<li>kubectl get cm</li>
<li>kubectl get cm hello-cm -o yaml</li>
<li>클라우드에서 배포 이미지 확인</li>
<li>nano cm-deployment.yaml 파일 편집(나의 Registry명으로 수정)</li>
<li>(배포 및 서비스 생성)
<ul>
<li>kubectl create -f cm-deployment.yaml</li>
<li>kubectl create -f cm-service.yaml</li>
</ul>
</li>
<li>(서비스 확인)
<ul>
<li>Service의 External-IP 접속</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Lab. Secret</p>
<ul>
<li>(pwd 로 현 위치가 /container-orchestration/yaml/secret/ 인지 확인)</li>
<li>(Pod에서 Secret 파일 마운트 사용하기 내용을 참고하여 배포 및 서비스 확인해 보기)</li>
</ul>
</li>
<li>
<p>Lab. Liveness &amp; Readiness Probe</p>
<ul>
<li>(pwd 로 현 위치가 /container-orchestration/yaml/liveness/ 인지 확인)</li>
<li>(Liveness Command Probe 실습)
<ul>
<li>kubectl create -f exec-liveness.yaml</li>
<li>(컨테이너가 Running 상태로 보이나, Liveness Probe 실패로 계속 재시작)</li>
<li>(kubectl describe로 실패 메시지 확인)</li>
<li>kubectl describe po liveness-exec</li>
</ul>
</li>
<li>(Liveness HTTP Probe 실습)
<ul>
<li>kubectl create -f http-liveness.yaml</li>
<li>(kubectl describe로 실패 메시지 확인)</li>
<li>kubectl describe po liveness-http</li>
</ul>
</li>
<li>(Liveness 와 readiness probe 동시 적용 실습)
<ul>
<li>kubectl create -f tcp-liveness-readiness.yaml</li>
<li>(8080포트에 대해 정상적으로 Liveness 와 readiness Probe를 통과해 서비스가 실행됨)</li>
<li>kubectl describe po goproxy</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Lab. Ingress</p>
<ul>
<li>Helm 명령으로 설치 여부 확인</li>
<li>Helm 이 설치되어 있지 않은 경우, Helm(패키지 인스톨러) 설치
<ul>
<li>Helm 3.x 설치(권장)
<ul>
<li>curl <a href="https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3">https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3</a> &gt; get_helm.sh</li>
<li>chmod 700 get_helm.sh</li>
<li>./get_helm.sh</li>
</ul>
</li>
<li>Helm 2.x 설치
<ul>
<li>curl <a href="https://raw.githubusercontent.com/kubernetes/helm/master/scripts/get">https://raw.githubusercontent.com/kubernetes/helm/master/scripts/get</a> | bash</li>
<li>(설치 중, sudo를 위한 비밀번호 입력)</li>
<li>kubectl --namespace kube-system create sa tiller</li>
<li>kubectl create clusterrolebinding tiller --clusterrole cluster-admin --serviceaccount=kube-system:tiller</li>
<li>helm init --service-account tiller</li>
</ul>
</li>
</ul>
</li>
<li>Helm으로 Ingress Controller 설치
<ul>
<li>helm repo add stable <a href="https://charts.helm.sh/stable">https://charts.helm.sh/stable</a></li>
<li>helm repo add ingress-nginx <a href="https://kubernetes.github.io/ingress-nginx">https://kubernetes.github.io/ingress-nginx</a></li>
<li>helm repo update</li>
<li>kubectl create namespace ingress-basic</li>
<li>helm version 확인</li>
<li>(helm version 2.x 일때)
<ul>
<li>helm install --name nginx-ingress stable/nginx-ingress  --namespace=ingress-basic</li>
</ul>
</li>
<li>(helm version 3.x 일때)
<ul>
<li>helm install nginx-ingress ingress-nginx/ingress-nginx --namespace=ingress-basic</li>
</ul>
</li>
<li>(설치확인)
<ul>
<li>kubectl get all --namespace=ingress-basic</li>
<li>(Ingress Controller의 EXTERNAL-IP가 API Gateway 엔드포인트: 메모 必)</li>
</ul>
</li>
</ul>
</li>
<li>Ingress 대상 서비스(BLUE, GREEN) 생성
<ul>
<li>(pwd 로 현 위치가 /container-orchestration/yaml/ingress/blue-svc/ 인지 확인)
<ul>
<li>(도커라이징 &amp; 이미지 Push)</li>
<li>az acr build --registry [acr-레지트스리명] --image [acr레지스트리명].azurecr.io/nginx-blue:latest .</li>
<li>(배포 전 yaml을 열어 image URL을 나의 ACR이름으로 수정)</li>
<li>nano nginx-blue-deployment.yaml</li>
<li>(저장 ctrl + X)</li>
<li>(배포 및 서비스 생성)</li>
<li>kubectl create -f nginx-blue-deployment.yaml</li>
</ul>
</li>
<li>(pwd 로 현 위치가 /container-orchestration/yaml/ingress/green-svc/ 인지 확인)
<ul>
<li>(도커라이징 &amp; 이미지 Push)</li>
<li>az acr build --registry [acr-레지트스리명] --image [acr레지스트리명].azurecr.io/nginx-green:latest .</li>
<li>(배포 전 yaml을 열어 image URL을 나의 ACR이름으로 수정)</li>
<li>nano nginx-green-deployment.yaml</li>
<li>(저장 ctrl + X)</li>
<li>(배포 및 서비스 생성)</li>
<li>kubectl create -f nginx-green-deployment.yaml</li>
</ul>
</li>
<li>(서비스 생성 확인)
<ul>
<li>kubectl get deploy,service -n ingress-basic</li>
</ul>
</li>
</ul>
</li>
<li>Ingress 생성
<ul>
<li>(pwd 로 현 위치가 /container-orchestration/yaml/ingress/ 인지 확인)</li>
<li>kubectl create -f web-ingress.yaml</li>
<li>(Ingress 생성확인)</li>
<li>kubectl get ingress -n ingress-basic</li>
</ul>
</li>
<li>Ingress 테스트
<ul>
<li>API Gateway 주소를 Local 시스템에 등록
<ul>
<li>관리자권한으로 CMD 실행</li>
<li>cd c:\</li>
<li>cd windows</li>
<li>cd system32</li>
<li>cd drivers</li>
<li>cd etc</li>
<li>notepad hosts</li>
<li>Windows - hosts 파일 맨 하단에 Ingress Controller의 External-IP 등록<br />
&quot;예시. 51.243.10.185	 <a href="http://blue.example.com">blue.example.com</a>  <a href="http://green.example.com">green.example.com</a>&quot;</li>
</ul>
</li>
<li>인그레이스 리소스 삭제</li>
<li>kubectl delete namespace ingress-basic</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</details>
<details>
<summary><b>Kubernetes Advanced Hands-on</b></summary>
<ul>
<li><b>Lab. Ingress</b>
<ul>
<li>Helm 명령으로 설치 여부 확인</li>
<li>Helm 이 설치되어 있지 않은 경우, Helm(패키지 인스톨러) 설치
<ul>
<li>Helm 3.x 설치(권장)
<ul>
<li>curl <a href="https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3">https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3</a> &gt; get_helm.sh</li>
<li>chmod 700 get_helm.sh</li>
<li>./get_helm.sh</li>
</ul>
</li>
<li>Helm 2.x 설치
<ul>
<li>curl <a href="https://raw.githubusercontent.com/kubernetes/helm/master/scripts/get">https://raw.githubusercontent.com/kubernetes/helm/master/scripts/get</a> | bash</li>
<li>(설치 중, sudo를 위한 비밀번호 입력)</li>
<li>kubectl --namespace kube-system create sa tiller</li>
<li>kubectl create clusterrolebinding tiller --clusterrole cluster-admin --serviceaccount=kube-system:tiller</li>
<li>helm init --service-account tiller</li>
</ul>
</li>
</ul>
</li>
<li>Helm으로 Ingress Controller 설치
<ul>
<li>helm repo add stable <a href="https://charts.helm.sh/stable">https://charts.helm.sh/stable</a></li>
<li>helm repo add ingress-nginx <a href="https://kubernetes.github.io/ingress-nginx">https://kubernetes.github.io/ingress-nginx</a></li>
<li>helm repo update</li>
<li>kubectl create namespace ingress-basic</li>
<li>helm version 확인</li>
<li>(helm version 2.x 일때)
<ul>
<li>helm install --name nginx-ingress stable/nginx-ingress  --namespace=ingress-basic</li>
</ul>
</li>
<li>(helm version 3.x 일때)
<ul>
<li>helm install nginx-ingress ingress-nginx/ingress-nginx --namespace=ingress-basic</li>
</ul>
</li>
<li>(설치확인)
<ul>
<li>kubectl get all --namespace=ingress-basic</li>
<li>(Ingress Controller의 EXTERNAL-IP가 API Gateway 엔드포인트: 메모 必)</li>
</ul>
</li>
</ul>
</li>
<li>Ingress 대상 서비스(BLUE, GREEN) 생성
<ul>
<li>(pwd 로 현 위치가 /container-orchestration/yaml/ingress/blue-svc/ 인지 확인)
<ul>
<li>(도커라이징 &amp; 이미지 Push)</li>
<li>az acr build --registry [acr-레지트스리명] --image [acr레지스트리명].azurecr.io/nginx-blue:latest .</li>
<li>(배포 전 yaml을 열어 image URL을 나의 ACR이름으로 수정)</li>
<li>nano nginx-blue-deployment.yaml</li>
<li>(저장 ctrl + X)</li>
<li>(배포 및 서비스 생성)</li>
<li>kubectl create -f nginx-blue-deployment.yaml</li>
</ul>
</li>
<li>(pwd 로 현 위치가 /container-orchestration/yaml/ingress/green-svc/ 인지 확인)
<ul>
<li>(도커라이징 &amp; 이미지 Push)</li>
<li>az acr build --registry [acr-레지트스리명] --image [acr레지스트리명].azurecr.io/nginx-green:latest .</li>
<li>(배포 전 yaml을 열어 image URL을 나의 ACR이름으로 수정)</li>
<li>nano nginx-green-deployment.yaml</li>
<li>(저장 ctrl + X)</li>
<li>(배포 및 서비스 생성)</li>
<li>kubectl create -f nginx-green-deployment.yaml</li>
</ul>
</li>
<li>(서비스 생성 확인)
<ul>
<li>kubectl get deploy,service -n ingress-basic</li>
</ul>
</li>
</ul>
</li>
<li>Ingress Routing Rule 생성
<ul>
<li>(pwd 로 현 위치가 /container-orchestration/yaml/ingress/ 인지 확인)</li>
<li>kubectl create -f path-based-ingress.yaml</li>
<li>kubectl get ingress -n ingress-basic</li>
</ul>
</li>
<li>Ingress 테스트
<ul>
<li>인그레이스 리소스 삭제
<ul>
<li>kubectl delete namespace ingress-basic</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</details>
<details>
<summary><b>Service Mesh, Istio Hands-on</b></summary>
<ul>
<li><b>Lab. Istio Install</b>
<ul>
<li>Istio 설치</li>
<li>curl -L <a href="https://istio.io/downloadIstio">https://istio.io/downloadIstio</a> | ISTIO_VERSION=1.7.1 TARGET_ARCH=x86_64 sh -</li>
<li>cd istio-1.7.1</li>
<li>
<pre style="white-space: pre-wrap">export PATH=$PWD/bin:$PATH</pre>
</li>
<li>istioctl install --set profile=demo --set <a href="http://hub=gcr.io/istio-release">hub=gcr.io/istio-release</a><br />
&quot;note : there are other profiles for production or performance testing.&quot;</li>
<li>Istio 모니터링 툴(Telemetry Applications) 설치
<ul>
<li>
<p>vi samples/addons/kiali.yaml</p>
</li>
<li>
<p>4라인의 apiVersion: <a href="http://apiextensions.k8s.io/v1beta1%EC%9D%84">apiextensions.k8s.io/v1beta1을</a> apiVersion: <a href="http://apiextensions.k8s.io/v1%EC%9C%BC%EB%A1%9C">apiextensions.k8s.io/v1으로</a> 수정</p>
</li>
<li>
<p>kubectl apply -f samples/addons</p>
</li>
<li>
<p>kiali.yaml 오류발생시, 아래 명령어 실행</p>
<blockquote>
<p>kubectl apply -f <a href="https://raw.githubusercontent.com/istio/istio/release-1.7/samples/addons/kiali.yaml">https://raw.githubusercontent.com/istio/istio/release-1.7/samples/addons/kiali.yaml</a></p>
</blockquote>
</li>
<li>
<p>모니터링(Tracing &amp; Monitoring) 툴 설정</p>
<ul>
<li>Monitoring Server - Kiali
<ul>
<li>기본 ServiceType 변경 : ClusterIP를 LoadBalancer 로…
<ul>
<li>kubectl edit svc kiali -n istio-system</li>
<li>:%s/ClusterIP/LoadBalancer/g</li>
<li>:wq!</li>
</ul>
</li>
<li>모니터링 시스템(kiali) 접속 : EXTERNAL-IP:20001 (admin/admin)</li>
</ul>
</li>
<li>Tracing Server - Jaeger
<ul>
<li>기본 ServiceType 변경 : ClusterIP를 LoadBalancer 로…
<ul>
<li>kubectl edit svc tracing -n istio-system</li>
<li>:%s/ClusterIP/LoadBalancer/g</li>
<li>:wq!</li>
</ul>
</li>
<li>분산추적 시스템(tracing) 접속 : EXTERNAL-IP:80</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>설치확인
<ul>
<li>kubectl get all -n istio-system</li>
</ul>
</li>
</ul>
</li>
<li><b>How to enable Istio</b>
<ul>
<li>
<ol>
<li>Whenever deploying to Cluster, Using pre-processing command “Istio kube-inject”</li>
</ol>
<ul>
<li>kubectl apply -f &lt;(istioctl kube-inject -f Deployment.yml) -n istio-test-ns</li>
</ul>
</li>
<li>
<ol start="2">
<li>Using Istio-enabled Namespace.</li>
</ol>
<ul>
<li>e.g. kubectl label namespace tutorial istio-injection=enabled</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><b>Lab. Istio Tutorial 셋업</b>
<ul>
<li>Git repository에서 Tutorial 리소스 가져오기
<ul>
<li>cd ~</li>
<li>git clone <a href="https://github.com/redhat-developer-demos/istio-tutorial">https://github.com/redhat-developer-demos/istio-tutorial</a></li>
<li>cd istio-tutorial</li>
</ul>
</li>
<li>네임스페이스 생성
<ul>
<li>kubectl create namespace tutorial</li>
</ul>
</li>
<li>Customer Service 배포
<ul>
<li>kubectl apply -f &lt;(istioctl kube-inject -f customer/kubernetes/Deployment.yml) -n tutorial
<ul>
<li>kubectl describe pod (Customer Pod) -n tutorial 로 생성확인</li>
</ul>
</li>
<li>kubectl create -f customer/kubernetes/Service.yml -n tutorial</li>
</ul>
</li>
<li>Istio Gateway 설치 및 Customer 서비스 라우팅(VirtualService) 설정
<ul>
<li>cat customer/kubernetes/Gateway.yml</li>
<li>kubectl create -f customer/kubernetes/Gateway.yml -n tutorial</li>
<li>(Istio-IngressGateway를 통한 Customer 서비스 확인)
<ul>
<li>kubectl get service/istio-ingressgateway -n istio-system</li>
<li>해당 EXTERNAL-IP가 Istio Gateway 주소</li>
<li>Customer 서비스 호출 :<pre style="white-space: pre-wrap">"http://istio-ingressgateway IP)/customer"</pre>
</li>
</ul>
</li>
</ul>
</li>
<li>Preference, Recommendation-v1 Service 배포
<ul>
<li>kubectl apply -f &lt;(istioctl kube-inject -f preference/kubernetes/Deployment.yml)  -n tutorial</li>
<li>kubectl create -f preference/kubernetes/Service.yml -n tutorial</li>
<li>kubectl apply -f &lt;(istioctl kube-inject -f recommendation/kubernetes/Deployment.yml) -n tutorial</li>
<li>kubectl create -f recommendation/kubernetes/Service.yml -n tutorial</li>
</ul>
</li>
</ul>
</li>
<li><b>Lab. Istio - Traffic Routing</b>
<ul>
<li>Simple Routing
<ul>
<li>(pwd 로 현 위치가 /istio-tutorial/ 인지 확인)</li>
<li>(recommendation 서비스 추가 배포: v2)
<ul>
<li>kubectl apply -f &lt;(istioctl kube-inject -f recommendation/kubernetes/Deployment-v2.yml) -n tutorial</li>
</ul>
</li>
<li>서비스 호출
<ul>
<li>브라우저에서 Customer 서비스(Externl-IP:8080 접속) 호출</li>
<li>F5(새로고침)를 10회 이상 클릭하여 다수의 요청 생성</li>
</ul>
</li>
<li>Routing 결과 확인 - Kiali(Externl-IP:20001) 접속</li>
<li>(Recommendation v.2 서비스 Scale Out)</li>
<li>(서비스의 v2 의 replica 를 2로 설정)
<ul>
<li>kubectl scale --replicas=2 deployment/recommendation-v2 -n tutorial</li>
<li>kubectl get po -n tutorial</li>
</ul>
</li>
<li>Customer 서비스를 10회 이상 F5(새로고침)하여 서비스 호출</li>
<li>Routing 결과 확인 - Kiali(Externl-IP:20001) 접속</li>
</ul>
</li>
<li>Advanced Routing
<ul>
<li>정책(VirtualService, DestinationRule) 설정
<ul>
<li>(현, 정책 확인)
<ul>
<li>kubectl get VirtualService -n tutorial -o yaml</li>
<li>kubectl get DestinationRule -n tutorial -o yaml</li>
</ul>
</li>
<li>(사용자 선호도에 따른 추천 서비스 라우팅 정책 설정)</li>
<li>(VirtualService, DestinationRule 설정, v2로 100% 라우팅)
<ul>
<li>kubectl create -f istiofiles/destination-rule-recommendation-v1-v2.yml -n tutorial</li>
<li>kubectl create -f istiofiles/virtual-service-recommendation-v2.yml -n tutorial</li>
</ul>
</li>
<li>(설정정책 확인)
<ul>
<li>kubectl get VirtualService -n tutorial -o yaml</li>
<li>kubectl get DestinationRule -n tutorial -o yaml</li>
</ul>
</li>
<li>(서비스 확인)
<ul>
<li>브라우저에서 Customer 서비스(Externl-IP:8080 접속)호출</li>
<li>Kiali(Externl-IP:20001), Jaeger(External-IP:80)에서 모니터링</li>
</ul>
</li>
</ul>
</li>
<li>가중치 기반 스마트 라우팅 (Canary Deployment)
<ul>
<li>(recommendation 서비스 v1의 가중치를 100으로 변경)
<ul>
<li>kubectl replace -f istiofiles/virtual-service-recommendation-v1.yml -n tutorial</li>
</ul>
</li>
<li>(서비스 호출 및 Kiali(Externl-IP:20001)에서 모니터링)</li>
<li>(VirtualService 삭제 시, Round-Robin 방식으로 동작)
<ul>
<li>kubectl delete -f istiofiles/virtual-service-recommendation-v1.yml -n tutorial</li>
</ul>
</li>
<li>Canary 라우팅 비율별 배포 정책 예시
<ul>
<li>(90 : 10)</li>
<li>kubectl apply -f istiofiles/virtual-service-recommendation-v1_and_v2.yml -n tutorial</li>
<li>(75 : 25)</li>
<li>kubectl replace -f istiofiles/virtual-service-recommendation-v1_and_v2_75_25.yml -n tutorial</li>
</ul>
</li>
<li>삭제
<ul>
<li>kubectl delete dr recommendation -n tutorial</li>
<li>#kubectl delete vs recommendation -n tutorial</li>
<li>kubectl scale --replicas=1 deployment/recommendation-v2 -n tutorial</li>
</ul>
</li>
</ul>
</li>
<li>Client 브라우저 유형별 스마트 라우팅
<ul>
<li>Firefox 브라우저로 접속 시, v2로 라우팅되도록 설정
<ul>
<li>kubectl apply -f istiofiles/destination-rule-recommendation-v1-v2.yml -n tutorial</li>
<li>kubectl apply -f istiofiles/virtual-service-firefox-recommendation-v2.yml -n tutorial</li>
</ul>
</li>
<li>(Firefox 브라우저와 다른 브라우저에서 접속 확인)</li>
<li>(Browser 환경이 지원되지 않을 경우,)
<ul>
<li>curl -A Safari Externl-IP:8080</li>
<li>curl -A Firefox Externl-IP:8080</li>
</ul>
</li>
<li>삭제
<ul>
<li>kubectl delete dr recommendation -n tutorial</li>
<li>kubectl delete vs recommendation -n tutorial</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><b>Lab. Istio - Timeout &amp; Retry</b>
<ul>
<li>Lab에 필요한 모듈(Message Queue) 설치
<ul>
<li>kubectl get svc my-kafka -n kafka</li>
<li>미설치시, 설치 링크 (<a href="https://workflowy.com/s/msa/27a0ioMCzlpV04Ib#/a7018fb8c629">https://workflowy.com/s/msa/27a0ioMCzlpV04Ib#/a7018fb8c629</a>)</li>
</ul>
</li>
<li>tutorial  네임스페이스에 Istio 기능 추가
<ul>
<li>kubectl label namespace tutorial istio-injection=enabled --overwrite</li>
<li>네임스페이스가 없을 시, 생성 후 실행</li>
</ul>
</li>
<li>Lab. Timeout : Fail-Fast를 통한 서비스 Caller 자원 보호
<ul>
<li>Timeout 테스트를 위해 CNA 과정에서 구현한 Order 마이크로서비스의  코드 보완 및 tutorial 네임스페이스에 배포
<ul>
<li>Service time delay를 위해, Order Aggregate(Order.java)에 저장전 Thread.sleep 코드 삽입<pre style="white-space: pre-wrap">
@PrePersist
    public void onPrePersist(){
    try {
      Thread.currentThread().sleep((long) (800 + Math.random() * 220));
    } catch (InterruptedException e) {
       e.printStackTrace();
    }
  }
</pre>
</li>
<li>Docker image Build &amp; Push</li>
<li>tutorial 네임스페이스에 Order 서비스 배포</li>
</ul>
<pre style="white-space: pre-wrap">
kubectl apply -f - &#60;&#60;EOF
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: order
      namespace: tutorial
      labels:
        app: order
    spec:
      replicas: 1
      selector:
        matchLabels:
          app: order
      template:
        metadata:
          labels:
            app: order
        spec:
          containers:
            - name: order
              image: IMAGE_FULL_REPOSITORY_URL/order:v1
              ports:
                - containerPort: 8080
              resources:
                limits:
                  cpu: 500m
                requests:
                  cpu: 200m
EOF
</pre>
<ul>
<li>Order 서비스 생성
<ul>
<li>kubectl expose deploy order --port=8080 -n tutorial</li>
</ul>
</li>
<li>Order 서비스 Timeout 설정 (Istio Gateway에서 Order 서비스로 라우팅 시)
<ul>
<li>(pwd 로 현 위치가 /istio-tutorial/ 인지 확인)</li>
<li>nano customer/kubernetes/Gateway.yaml 오픈 후 마지막 행 다음에 타임아웃 설정이 포함된 아래 내용 추가<pre style="white-space: pre-wrap">
- match:
  - uri:"
  prefix: /orders
  route:
- destination:
  host: order
  port:
  number: 8080
  timeout: 3s
</pre>
</li>
<li>(변경 내용 적용)</li>
<li>kubectl apply -f customer/kubernetes/Gateway.yml -n tutorial</li>
</ul>
</li>
<li>Order 서비스 Timeout 설정 (클라우드 내에서 Order 서비스로 라우팅시)</li>
</ul>
  <pre style="white-space: pre-wrap">
  kubectl apply -f - &#60;&#60;EOF
    apiVersion: networking.istio.io/v1alpha3
    kind: VirtualService
    metadata:
      name: vs-order-network-rule
      namespace: tutorial
    spec:
      hosts:
      - order
      http:
      - route:
        - destination:
            host: order
        timeout: 3s
  EOF
  </pre>
<ul>
<li>부하테스트 툴(Siege) 설치 및 Order 서비스 Load Testing
<ul>
<li>kubectl run siege --image=apexacme/siege-nginx -n tutorial</li>
<li>kubectl exec -it siege -c siege -n tutorial -- /bin/bash</li>
<li>
<pre style="white-space: pre-wrap">siege -c30 -t20S -v --content-type "application/json" 'http://order:8080/orders POST {"productId": "1001", "qty":5}'</pre>
</li>
</ul>
</li>
</ul>
</li>
<li>Order 서비스에 설정된 Timeout을 임계치를 초과하는 순간, Istio에서 서비스로의 연결을 자동 차단하는 것을 확인</li>
</ul>
</li>
<li>Lab. Retry : 5xx 오류를 리턴받게 되면, Envoy Proxy에서 설정한 횟수만큼 대상 서비스를 재호출하여 일시적인 장애였는지를 다시 확인하는 Rule
<ul>
<li>Retry 테스트를 위해 CNA 과정에서 구현한 Delivery 마이크로서비스를 tutorial 네임스페이스에 배포</li>
<li>Docker image Build &amp; Push</li>
<li>tutorial 네임스페이스에 Delivery 서비스 배포<pre style="white-space: pre-wrap">
kubectl apply -f - &#60;&#60;EOF
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: delivery
    namespace: tutorial
    labels:
      app: delivery
  spec:
    replicas: 1
    selector:
      matchLabels:
        app: delivery
    template:
      metadata:
        labels:
          app: delivery
      spec:
        containers:
          - name: delivery
            image: IMAGE_FULL_REPOSITORY_URL/delivery:v1
            ports:
              - containerPort: 8080
            resources:
              limits:
                cpu: 500m
              requests:
                cpu: 200m
EOF
</pre>
</li>
<li>Delivery 서비스 생성
<ul>
<li>kubectl expose deploy delivery --port=8080 -n tutorial</li>
</ul>
</li>
<li>Order 서비스에 Retry Rule 추가 적용<pre style="white-space: pre-wrap">
kubectl apply -f - &#60;&#60;EOF
  apiVersion: networking.istio.io/v1alpha3
  kind: VirtualService
  metadata:
    name: vs-order-network-rule
    namespace: tutorial
  spec:
    hosts:
    - order
    http:
    - route:
      - destination:
          host: order
      timeout: 3s
      retries:
        attempts: 3
        perTryTimeout: 2s
        retryOn: 5xx,retriable-4xx,gateway-error,connect-failure,refused-stream
EOF
</pre>
</li>
<li>Delivery 서비스를 정지하고, 이를 동기호출하는 Order 서비스 API 호출
<ul>
<li>kubectl scale deploy delivery --replicas=0 -n tutorial</li>
<li>kubectl exec -it siege -c siege -n tutorial --/bin/bash</li>
<li>http <a href="http://order:8080/orders/">http://order:8080/orders/</a> productId=1001 qty=5
<ul>
<li>httpie가 없을 시,</li>
<li>apt-get update</li>
<li>apt-get install httpie</li>
</ul>
</li>
<li>http DELETE <a href="http://order:8080/orders/1">http://order:8080/orders/1</a></li>
</ul>
</li>
<li>Jaeger 접속(<a href="http://tracing">http://tracing</a> svc EXTERNAL-IP :80) 후, Retry 횟수 확인하기<br />
&quot;&lt; 검색조건 &gt;<br />
Service : order.tutorial, Operation : delivery.tutorial.svc.cluster.local:8080/*<br />
검색결과 : 총 Retry 횟수 + 1 의 Requests 로깅&quot;</li>
</ul>
</li>
</ul>
</li>
<li><b>Lab. Istio - Circuit Breaker</b>
<ul>
<li>Circuit Breaker : 장애 인스턴스를 회피하는 기능으로 5xx 오류를 리턴한 인스턴스를  라우팅 대상에서 일정시간 만큼 제외 (Pool Ejection)</li>
<li>Namespace 생성 및 Istio 활성
<ul>
<li>kubectl create namespace istio-cb-ns</li>
<li>kubectl label namespace istio-cb-ns istio-injection=enabled</li>
</ul>
</li>
<li>Istio Retry 디폴트 동작 확인
<ul>
<li>테스트 어플리케이션 배포
<ul>
<li>hello-server-1, hello-server-2 Pods, Service</li>
<li>hello-server 앱은 env:RANDOM_ERROR 값의 확률로 랜덤하게 503 에러를 발생하는 로직이 포함.<pre style="white-space: pre-wrap">
kubectl apply -f - &#60;&#60; EOF
  apiVersion: v1
  kind: Pod
  metadata:
    name: hello-server-1
    namespace: istio-cb-ns
    labels:
      app: hello
  spec:
    containers:
      - name: hello-server-1
      image: docker.io/honester/hello-server:latest
      imagePullPolicy: IfNotPresent
      env:
      - name: VERSION
        value: "v1"
      - name: LOG
        value: "1"
  &#45;&#45;&#45;
  apiVersion: v1
  kind: Pod
  metadata:
    name: hello-server-2
    namespace: istio-cb-ns
    labels:
      app: hello
  spec:
    containers:
      - name: hello-server-2
      image: docker.io/honester/hello-server:latest
      imagePullPolicy: IfNotPresent
      env:
      - name: VERSION
        value: "v2"
      - name: LOG
        value: "1"
      - name: RANDOM_ERROR
        value: "0.2"
  &#45;&#45;&#45;
  apiVersion: v1
  kind: Service
  metadata:
    name: svc-hello
    namespace: istio-cb-ns
    labels:
      app: hello
  spec:
    selector:
      app: hello
    ports:
      - name: http
      protocol: TCP
      port: 8080
EOF
</pre>
</li>
<li>클라이언트용 서비스(httpbin) 배포<pre style="white-space: pre-wrap">
kubectl apply -f - &#60;&#60;EOF
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: httpbin
    namespace: istio-cb-ns
  spec:
    replicas: 1
    selector:
      matchLabels:
        app: httpbin
    template:
      metadata:
        labels:
          app: httpbin
      spec:
        containers:
        - name: httpbin
          image: docker.io/honester/httpbin:latest
          imagePullPolicy: IfNotPresent
          ports:
          - containerPort: 80
  &#45;&#45;&#45;
  apiVersion: v1
  kind: Service
  metadata:
    name: httpbin
    namespace: istio-cb-ns
    labels:
      app: httpbin
  spec:
    selector:
      app: httpbin
    ports:
      - name: http
      port: 8000
      targetPort: 80
EOF
</pre>
</li>
</ul>
</li>
<li>Retry 디폴트 동작 테스트
<ul>
<li>hello-server-2의 로그 모니터 걸기
<ul>
<li>kubectl logs -f hello-server-2 -c hello-server-2 -n istio-cb-ns</li>
</ul>
</li>
<li>클라이언트에서 svc-hello 서비스 10번 호출하기
<ul>
<li>for i in {1…10}; do kubectl exec -it httpbin -c httpbin -n istio-cb-ns --curl http://svc-hello.istio-cb-ns:8080; sleep 0.1; done</li>
</ul>
</li>
</ul>
</li>
<li>결과 확인/분석<br />
&quot;1) 서비스 호출은 Round Robin으로 로드 밸런싱되나, 프로세싱 시간에 따라 동일한 서비스가 연속 2회 로깅 될 수 있음
<ol start="2">
<li>핵심포인트는, Server-2가 5xx 오류를 리턴할 경우, 자동으로 Retry되어 Server-1 로그가 연달아 출력된다는 점임. (Default Retry : 2회)&quot;</li>
</ol>
</li>
</ul>
</li>
<li>Circuit Breaker 설정
<ul>
<li>대기 쓰레드수 기반 Circuit Breaker
<ul>
<li>클라이언트용 서비스(httpbin)에 쓰레드 기반 Circuit Breaker 설정</li>
<li>(Pending Thread가 많을수록 경우, 오랫동안 큐잉된 요청은 Response time이 증가하게 되므로, 적절한 대기 쓰레드를 풀을 적용하여 Circuit Breaking)<pre style="white-space: pre-wrap">
kubectl apply -f - &#60;&#60;EOF
  apiVersion: networking.istio.io/v1alpha3
  kind: DestinationRule
  metadata:
    name: dr-httpbin
    namespace: istio-cb-ns
  spec:
    host: httpbin
    trafficPolicy:
      connectionPool:
        http:
          http1MaxPendingRequests: 1
          maxRequestsPerConnection: 1
EOF
</pre>
</li>
<li>Circuit Breaker 동작 확인
<ul>
<li>부하테스트 툴(Siege) 설치 및  Load Testing
<ul>
<li>kubectl run siege --image=apexacme/siege-nginx -n istio-cb-ns</li>
<li>kubectl exec -it siege -c siege -n istio-cb-ns --/bin/bash
<ul>
<li>siege -c1 -t10S -v <a href="http://httpbin:8000/get">http://httpbin:8000/get</a>  # 100% availability</li>
<li>siege -c2 -t10S -v <a href="http://httpbin:8000/get">http://httpbin:8000/get</a>  # 87% availability</li>
</ul>
</li>
</ul>
</li>
<li>Kiali(Externl-IP:20001) 모니터링</li>
</ul>
</li>
</ul>
</li>
<li>로드 밸런싱 풀(pool) 인스턴스의 Health Status 기반 Circuit Breaker
<ul>
<li>Hello 서비스의 로드 밸런싱 풀(pool)의 인스턴스 상태기반 Circuit Breaker 설정<pre style="white-space: pre-wrap">
kubectl apply -f - &#60;&#60;EOF
  apiVersion: networking.istio.io/v1alpha3
  kind: DestinationRule
  metadata:
    name: dr-hello-server
    namespace: istio-cb-ns
  spec:
    host: svc-hello
    trafficPolicy:
      outlierDetection:
        interval: 1s
        consecutiveErrors: 1
        baseEjectionTime: 3m
        maxEjectionPercent: 100
EOF
</pre>
</li>
<li>Circuit Breaker 동작 확인
<ul>
<li>클라이언트(httpbin Pod)에서 svc-hello 호출
<ul>
<li>hello-server-2의 로그 모니터 걸기
<ul>
<li>kubectl logs -f hello-server-2 -c hello-server-2 -n istio-cb-ns</li>
</ul>
</li>
<li>클라이언트에서 svc-hello 서비스 10번 호출하기
<ul>
<li>for i in {1…10}; do kubectl exec -it httpbin -c httpbin -n istio-cb-ns --curl http://svc-hello.istio-cb-ns:8080; sleep 0.1; done</li>
</ul>
</li>
<li>결과 확인/분석<br />
&quot;1) 5초 동안 5xx 에러가 2번 발생할 경우, Server-2로는 5분 동안 트래픽이 라우팅 되지 않는다.
<ol start="2">
<li>모니터링 시스템(Kiali) : EXTERNAL-IP:20001 에서 Circuit Breaker 뱃지 발생 확인&quot;</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>동기호출 Target인 배송(Delivery) 서비스에 Circuit Breaker 설정하기
<ul>
<li>Thread 부하 및 5XX 오류에 대해 서비스를 차단하는 Circuit Breaker 생성<pre style="white-space: pre-wrap">
kubectl apply -f - &#60;&#60;EOF
  apiVersion: networking.istio.io/v1alpha3
  kind: DestinationRule
  metadata:
    name: dr-delivery
    namespace: tutorial
  spec:
    host: delivery
    trafficPolicy:
      connectionPool:
        http:
          http1MaxPendingRequests: 30
          maxRequestsPerConnection: 100
      outlierDetection:
        interval: 5s
        consecutiveErrors: 1
        baseEjectionTime: 5m
        maxEjectionPercent: 100
EOF
</pre>
</li>
<li>설정 내용
<ul>
<li>최대 활성 연결 갯수 30개와 최대 요청 대기 수를 100개로 지정하고, 이 임계점을 넘어가는 추가 요청은 거부(circuit break)</li>
<li>5초 동안 2번 5xx을 리턴한 서비스는 5분 동안 라우팅 대상에서 제외(Ejection)</li>
<li>또한, 모든 대상 서비스 인스턴스가 방출(제외)될 수 있음</li>
</ul>
</li>
</ul>
</li>
<li>Clean-up
<ul>
<li>kubectl delete pod/hello-server-1 pod/hello-server-2 pod/httpbin service/svc-hello dr/dr-hello -n istio-cb-ns</li>
</ul>
</li>
</ul>
</li>
<li><b>Clear Istio </b>
<ul>
<li>kubectl delete ns tutorial istio-cb-ns istio-system</li>
</ul>
</li>
</ul>
</details>
</p>
</details>
<hr />
<h3>마이크로소프트 Azure</h3>
<details>
<summary>Azure Cloud 기반의 Container Orchestration Lab. Scripts</summary>
<p>
<details>
<summary><b>자주 사용되는 Azure Cloud 명령어</b></summary>
<ul>
<li><b>구독(종량제) 설정</b>
<ul>
<li>ex) az account set --subscription “종량제2”</li>
</ul>
</li>
<li><b>Azure 클러스터 생성</b>
<ul>
<li>az aks create --resource-group user01_resource_group --name user01_cluster --node-count 2 --enable-addons monitoring --generate-ssh-keys</li>
</ul>
</li>
<li><b>Azure 클러스터 토큰 가져오기</b>
<ul>
<li>az aks get-credentials --resource-group (user01_resource_group) --name (user01-cluster)</li>
</ul>
</li>
<li><b>Azure 컨테이너 레지스트리 생성</b>
<ul>
<li>az acr create --resource-group (user01_resource_group) --name (user01) --sku Basic</li>
</ul>
</li>
<li><b>Azure 컨테이너 레지스트리 로그인</b>
<ul>
<li>az acr login --name (user01)</li>
</ul>
</li>
<li><b>Azure 클러스터(AKS)에 레지스트리(ACR) 붙이기</b>
<ul>
<li>az aks update -n (user01_cluster) -g (user01_resource_group) --attach-acr (user01_registry)</li>
</ul>
</li>
<li><b>Azure 레지스트리(ACR)에 도커 이미지 푸시하기</b>
<ul>
<li>az acr build --registry [acr-레지트스리명] --image [acr레지스트리명].azurecr.io/[이미지명]:latest .</li>
</ul>
</li>
<li><b>Azure 클러스터 삭제</b>
<ul>
<li>az aks delete --name MyManagedCluster --resource-group MyResourceGroup</li>
</ul>
</li>
<li><b>Azure 리소스그룹 삭제</b>
<ul>
<li>az group delete --name rsrcgroup</li>
</ul>
</li>
<li><b>Azure AKS 모니터링</b>
<ul>
<li>admin-user 서비스 계정 및 클러스터 롤 바인딩 생성<pre style="white-space: pre-wrap">
cat &#60;&#60;EOF | kubectl apply -f -
&#45;&#45;&#45;
apiVersion: v1
kind: ServiceAccount
metadata:
  name: admin-user
  namespace: kube-system
&#45;&#45;&#45;
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRoleBinding
metadata:
  name: admin-user
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
- kind: ServiceAccount
  name: admin-user
  namespace: kube-system
EOF
</pre>
</li>
<li>인증 토큰 조회
<ul>
<li>
<pre style="white-space: pre-wrap">kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin-user | awk "{print $1}")</pre>
</li>
</ul>
</li>
<li>az aks browse --resource-group (resource-group-name) --name (cluster-name)</li>
<li>복사된 토큰값 붙여넣기 및 로그인</li>
</ul>
</li>
</ul>
</details>
<h3>Docker</h3>
<details>
<summary><b>Setup</b></summary>    </b>
<ul>
<li><b>관리자 권한으로 PowerShell 실행</b>
<ul>
<li>Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux</li>
</ul>
</li>
<li><b>리눅스설치 및 실행</b>
<ul>
<li>(설치전 확인 사항)
<ul>
<li>Windows 기능 켜기/끄기에서 “Linux용 Windows 하위시스템 활성화” 확인</li>
<li>개발자 기능사용에서 “개발자 모드” 활성화 확인</li>
</ul>
</li>
<li>Ubuntu의 Archive Repository Server를 (빠른 패키지 설치를 위해) 국내로 설정
<ul>
<li>sudo vi /etc/apt/sources.list</li>
<li>:%s/archive.ubuntu.com/ftp.daumkakao.com/g</li>
<li>:wq!</li>
<li>sudo apt-get update</li>
</ul>
</li>
</ul>
</li>
<li><b>Linux에 JDK 설치</b>
<ul>
<li>(설치 명령)</li>
<li>sudo apt-get update</li>
<li>sudo apt install default-jdk</li>
<li>(bash에 환경변수 추가)</li>
<li>cd ~</li>
<li>nano .bashrc</li>
<li>(맨아래로 이동)</li>
<li>(JAVA_HOME 설정 및 실행 Path 추가)<pre style="white-space: pre-wrap">
export JAVA_HOME=‘/usr/lib/jvm/java-11-openjdk-amd64
export PATH=$PATH:$JAVA_HOME/bin:.
</pre>
</li>
<li>(수정사항 반영)
<ul>
<li>ctrl + x, y 입력, 종료</li>
<li>source ~/.bashrc</li>
</ul>
</li>
<li>(설치 확인)</li>
<li>echo $JAVA_HOME</li>
<li>java -version</li>
</ul>
</li>
<li><b>Windows에 도커 데몬 설치</b>
<ul>
<li><a href="https://www.docker.com/products/docker-desktop">https://www.docker.com/products/docker-desktop</a></li>
</ul>
</li>
<li><b>도커허브 계정생성</b>
<ul>
<li><a href="http://hub.docker.com">http://hub.docker.com</a> 접속 후, Sign Up (회원가입)</li>
</ul>
</li>
<li><b>리눅스에 도커 Client 설치</b>
<ul>
<li>sudo apt-get update</li>
<li>비밀번호 입력창에 skadmin1234</li>
<li>sudo apt install apt-transport-https ca-certificates curl software-properties-common</li>
<li>curl -fsSL <a href="https://download.docker.com/linux/ubuntu/gpg">https://download.docker.com/linux/ubuntu/gpg</a> | sudo apt-key add</li>
<li>
<pre style="white-space: pre-wrap">sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable"</pre>
</li>
<li>sudo apt update</li>
<li>sudo apt install docker-ce</li>
<li>#리눅스 설치시 생성한 사용자 명 입력</li>
<li>sudo usermod -aG docker skccadmin</li>
</ul>
</li>
<li><b>도커 데몬과 도커 Client 연결 </b>
<ul>
<li>cd</li>
<li>nano .bashrc</li>
<li>맨아래 줄에 아래 환경변수 추가
<ul>
<li>방향키로 맨 아래까지 내린 다음, 새로운 행에 아래 내용 입력</li>
<li>export DOCKER_HOST=tcp://0.0.0.0:2375</li>
<li>저장 &amp; 종료 : Ctrl + x, 입력 후, y 입력  후 엔터</li>
</ul>
</li>
<li>source ~/.bashrc</li>
<li>연결 확인
<ul>
<li>docker images</li>
<li>docker run --name nginx -d -p 80:80 nginx</li>
<li>docker images</li>
</ul>
</li>
</ul>
</li>
</ul>
</details>
 <details>
<summary><b>Docker Hands-On</b></summary>
<ul>
<li><b>Lab. image</b>
<ul>
<li>이미지 Pull
<ul>
<li>docker pull hello-world</li>
<li>docker images</li>
<li>docker pull nginx</li>
<li>docker pull nginx:latest</li>
<li>docker pull <a href="http://docker.io/library/nginx:latest">docker.io/library/nginx:latest</a></li>
<li>docker pull nginx:1.16.1</li>
<li>docker images</li>
</ul>
</li>
<li>도커허브 (Docker Hub)
<ul>
<li><a href="http://hub.docker.com">http://hub.docker.com</a> # 접속 후, nginx 검색</li>
</ul>
</li>
<li>이미지 Tagging
<ul>
<li>docker image tag nginx my-nginx # Create 태그</li>
</ul>
</li>
<li>이미지 삭제
<ul>
<li>docker image rm my-nginx</li>
<li>docker image rm hello-world</li>
<li>docker image rm $(docker images -q) # 한번에 모든 도커 이미지 지우기</li>
</ul>
</li>
</ul>
</li>
<li><b>Lab. container</b>
<ul>
<li>컨테이너 생성
<ul>
<li>docker run hello-world # 컨테이너 만들기</li>
<li>docker run --name hello hello-world # 이름 지정, 미지정시 임의의 이름으로 생성</li>
<li>docker run --name my-nginx -d -p 80:80 nginx</li>
<li>docker ps</li>
</ul>
</li>
<li>컨테이너 시작/종료
<ul>
<li>docker stop my-nginx</li>
<li>docker start my-nginx</li>
</ul>
</li>
<li>컨테이너 포트 노출
<ul>
<li><a href="http://localhost">http://localhost</a> 에서 nginx index.html 확인</li>
<li>docker container rm my-nginx</li>
<li>docker run --name my-nginx -d -p 8080:80 nginx</li>
<li><a href="http://localhost:8080">http://localhost:8080</a> 에서 nginx index.html 확인</li>
</ul>
</li>
<li>컨테이너 접근
<ul>
<li>docker exec my-nginx cat /usr/share/nginx/html/index.html #실행 중 컨테이너 접근</li>
<li>docker exec -i -t  my-nginx /bin/bash
<ul>
<li>apt-get update</li>
<li>apt-get install curl</li>
<li>curl localhost</li>
<li>exit</li>
</ul>
</li>
</ul>
</li>
<li>컨테이너 삭제
<ul>
<li>docker container rm my-nginx # 실행 중 컨테이너  삭제 시, 오류</li>
<li>docker container rm $(docker ps -a -q) # 한번에 모든 컨테이너 지우기</li>
</ul>
</li>
</ul>
</li>
<li><b>Lab. Docker Build &amp; Push</b>
<ul>
<li>Dockerfile로부터 이미지 생성
<ul>
<li>Dockerfile &amp; 리소스 생성
<ul>
<li>mkdir Dockerfile</li>
<li>cd Dockerfile</li>
<li>nano index.html<pre style="white-space: pre-wrap">"Hi~ My name is Park Yong Joo.."</pre>
<ul>
<li>저장 및 종료 (Ctrl + X, y 입력 후 엔터)</li>
<li>nano Dockerfile<pre style="white-space: pre-wrap">
FROM nginx
COPY index.html /usr/share/nginx/html/
</pre>
</li>
</ul>
</li>
<li>저장 및 종료 (Ctrl + x, Y 입력 후 엔터)</li>
</ul>
</li>
<li>도커라이징 &amp; Push
<ul>
<li>docker build -t (Docker-ID)/my-nginx:v1 .</li>
<li>docker images</li>
<li>docker push (Docker-ID)/my-nginx:v1<br />
&quot;denied: 권한오류 생성 시, docker login 명령으로 Docker Hub에 로그인해 준다.&quot;</li>
</ul>
</li>
<li><a href="http://hub.docker.com">http://hub.docker.com</a> 에서 이미지 확인</li>
<li>Docker Hub 이미지로부터 컨테이너 실행
<ul>
<li>docker run --name new-nginx -d -p 80:80 (Docker-ID)/my-nginx</li>
</ul>
</li>
<li>Browser에서 실행 애플리케이션 확인
<ul>
<li><a href="http://localhost:8080">http://localhost:8080</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><b>Clear</b>
<ul>
<li>docker container rm $(docker ps -a -q)
<ul>
<li>container 삭제 전, 실행 중인 컨테이너를 정지시켜 준다.</li>
<li>docker container stop new-nginx</li>
</ul>
</li>
<li>docker image rm -f $(docker images -q)</li>
</ul>
</li>
</ul>
</details>
<h3>Kubernetes</h3>
 <details>
<summary><b>Cloud Setup</b></summary>
<ul>
<li>
<p><b>Cloud Shell 에서 Setup 확인 명령</b></p>
<ul>
<li>az aks get-credentials --resource-group My_Resource_Group --name My-cluster</li>
<li>kubectl config current-context</li>
</ul>
</li>
<li>
<p><b>Cloud Client Setup</b></p>
<ul>
<li>Kubectl 설치 (ubuntu 18.04)
<ul>
<li>sudo apt-get update &amp;&amp; sudo apt-get install -y apt-transport-https</li>
<li>curl -s <a href="https://packages.cloud.google.com/apt/doc/apt-key.gpg">https://packages.cloud.google.com/apt/doc/apt-key.gpg</a> | sudo apt-key add -</li>
<li>
<pre style="white-space: pre-wrap">echo "deb https://apt.kubernetes.io/ kubernetes-xenial main" | sudo tee -a /etc/apt/sources.list.d/kubernetes.list</pre>
</li>
<li>sudo apt-get update</li>
<li>sudo apt-get install -y kubectl</li>
</ul>
</li>
<li>Azure-Cli 설치
<ul>
<li>curl -sL <a href="https://aka.ms/InstallAzureCLIDeb">https://aka.ms/InstallAzureCLIDeb</a> | sudo bash</li>
<li>az login -u ~~ -p ~~</li>
</ul>
</li>
<li>Local에 AKS(Azure Kubernetes Service) 클러스터 접속정보 설정
<ul>
<li>az aks get-credentials --resource-group [azure-resource-name] --name [azure-cluster-name]</li>
<li>kubectl config current-context</li>
<li>kubectl get all</li>
</ul>
</li>
<li>Local에 ACR(Azure Container Registry) 접속정보 설정
<ul>
<li>az acr login --name [azure-registry-name]</li>
</ul>
</li>
<li>Azure AKS와 ACR 연결 (4&quot;)
<ul>
<li>az aks update -n [azure-cluster-name] -g [azure-resource-Group-name] --attach-acr [azure-acr-name]</li>
</ul>
</li>
</ul>
</li>
</ul>
</details>
<details>
<summary><b>Kubernetes Hands-on</b></summary>
<ul>
<li>
<p><b>Lab에 필요한 리소스 내려받기</b></p>
<ul>
<li>git clone <a href="https://github.com/acmexii/mall.git">https://github.com/acmexii/mall.git</a></li>
<li>git clone <a href="https://github.com/event-storming/container-orchestration.git">https://github.com/event-storming/container-orchestration.git</a></li>
<li>cd container-orchestration</li>
<li>cd yaml</li>
</ul>
</li>
<li>
<p><b>Lab. K8s Sample App 생성</b></p>
<ul>
<li>어플리케이션 생성/ 확인
<ul>
<li>Docker hub에 올린 이미지를 통한 컨테이너 생성<br />
kubectl create deploy my-nginx --image=apexacme/my-nginx:v1&quot;</li>
<li>클러스터 외부에 노출하기<br />
kubectl expose deploy my-nginx --type=LoadBalancer --port=80&quot;</li>
</ul>
</li>
<li>서비스 확인하기
<ul>
<li>kubectl get svc의 EXTERNAL-IP 복사</li>
<li>Browser에서 EXTERNAL-IP:80 접속</li>
</ul>
</li>
</ul>
</li>
<li>
<p><b>Lab. Pod &amp; 기본명령</b></p>
<ul>
<li>kubectl get nodes
<ul>
<li>쿠버네티스에 제대로 접속했는지 확인</li>
<li>현 클러스터의 워크노드를 리스트업</li>
<li>접속 결과 안나오는 경우
<ul>
<li>kubectl config current-context 명령으로 Cluster 접속 확인</li>
</ul>
</li>
</ul>
</li>
<li>객체의 검색
<ul>
<li>kubectl get [object type]</li>
<li>kubectl get pods   # pods = pod = po</li>
<li>kubectl get deployments   # deploy</li>
<li>kubectl get services    # svc</li>
<li>kubectl get replicaset    # rs</li>
</ul>
</li>
<li>객체의 모니터링
<ul>
<li>watch kubectl get all</li>
<li>kubectl get pod -w</li>
<li>watch kubectl get pod</li>
</ul>
</li>
<li>객체의 유형
<ul>
<li>Service
<ul>
<li>types
<ul>
<li>LoadBalancer
<ul>
<li>클라우드 제공자에 의해 제공된 Loadbalancer 로 노출</li>
<li>front-end 혹은 ingress (api gateway)</li>
</ul>
</li>
<li>ClusterIP(default) / NodePort
<ul>
<li>클러스터 내부 IP</li>
<li>내부 마이크로 서비스</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Deployment
<ul>
<li>ReplicaSet (하나이상 생성)
<ul>
<li>Pod (하나이상 생성)
<ul>
<li>Container (docker ) 하나이상.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Pod</li>
<li>ReplicaSet</li>
<li>Ingress</li>
<li>Secret</li>
<li>ConfigMap</li>
<li>ServiceAccount = sa</li>
<li>statefulset</li>
<li>daemonset</li>
</ul>
</li>
<li>설정파일(YAML)을 통한 Pod 배포 (직접 타이핑)
<ul>
<li>nano declarative-pod.yaml<pre style="white-space: pre-wrap">
apiVersion: v1
kind: Pod
metadata:
  name: declarative-pod
  labels:
    env: test
spec:
  containers:
  - name: memory-demo-ctr
    image: nginx
</pre>
</li>
<li>저장 및 종료 (ctrl + X, Y, 엔터)</li>
<li>kubectl create -f declarative-pod.yaml</li>
<li>kubectl get pods</li>
</ul>
</li>
<li>원하는 Node 타입에 Pod 생성
<ul>
<li>#pwd 로 현 위치가 /container-orchestration/yaml/pod 인지 확인</li>
<li>kubectl create -f pod-with-nodeselector.yaml</li>
<li>kubectl get po -o wide
<ul>
<li>Pod가 찾는 노드가 없어 pending 상태</li>
</ul>
</li>
<li>노드에 라벨 추가
<ul>
<li>kubectl label nodes [your-node-name] disktype=ssd</li>
<li>kubectl get nodes --show-labels | grep ssd</li>
</ul>
</li>
<li>kubectl get po -o wide</li>
</ul>
</li>
<li>Pod 생성 전 초기화
<ul>
<li>kubectl create -f pod-initialize.yaml</li>
<li>kubectl get po</li>
<li>#생성된 Pod 내로 접근</li>
<li>kubectl exec -it init-demo --/bin/bash</li>
<li>cd /usr/share/nginx/html</li>
<li>ls</li>
</ul>
</li>
<li>생성된 Pod 및 오브젝트 삭제
<ul>
<li>kubectl delete pod [pod명]</li>
<li>kubectl delete service,deploy --all</li>
</ul>
</li>
</ul>
</li>
<li>
<p><b>Lab. Label </b></p>
<ul>
<li>kubectl run nginx --image=nginx</li>
<li>kubectl get pods -l run=nginx</li>
<li>kubectl get pods --selector run=nginx</li>
<li>
<pre style="white-space: pre-wrap">kubectl get pods --selector "run in (nginx, test)"</pre>
</li>
</ul>
</li>
<li>
<p><b>Lab. ReplicaSet</b></p>
<ul>
<li>pwd 로 현 위치가 /container-orchestration/yaml/replicaset 인지 확인</li>
<li>kubectl create -f replicaset.yaml</li>
<li>kubectl get all</li>
<li>#replica 개수 조정
<ul>
<li>kubectl scale replicaset/frontend --replicas=5</li>
<li>kubectl get po</li>
</ul>
</li>
</ul>
</li>
<li>
<p><b>Lab. Deployment &amp; 기본명령 </b></p>
<ul>
<li>기본 nginx 서버의 배포</li>
<li>kubectl create deploy nginx --image=nginx</li>
<li>kubectl get deploy nginx</li>
<li>kubectl get replicaset -l app=nginx</li>
<li>kubectl get po -l app=nginx  # “-l” 옵션은 label의 key/value 로 객체를 필터링</li>
<li>kubectl get pods --selector app=nginx</li>
<li>
<pre style="white-space: pre-wrap">kubectl get pods --selector "app in (nginx, test)"</pre>
</li>
<li>kubectl describe po (검색한 pod name)</li>
<li>(pod 제거)</li>
<li>kubectl delete po --all   #</li>
<li>(pod 를 제거해도 재생됨을 확인)</li>
<li>kubectl get po</li>
<li>(scale out)</li>
<li>kubectl scale deploy nginx --replicas=3</li>
<li>kubectl get po   # pod 개수가 3개로 늘어남을 확인</li>
<li>kubectl delete po --all   # pod 를 모두 지움</li>
<li>kubectl get po   # pod 를 모두 지워도 결국 3개로 복원됨을 확인</li>
<li>( 제거하기 위해서는 deployment 를 제거해야만 함)</li>
<li>kubectl delete deploy nginx</li>
</ul>
</li>
<li>
<p><b>Lab. Rollout &amp; Back</b></p>
<ul>
<li>(pwd 로 현 위치가 /container-orchestration/yaml/ 인지 확인)</li>
<li>kubectl create -f nginx.yaml</li>
<li>(아래 명령으로 배포 주석 추가, Rollback시 필요)</li>
<li>
<pre style="white-space: pre-wrap">kubectl annotate deploy nginx-deployment kubernetes.io/change-cause="v1 is nginx:1.7.9"</pre>
</li>
<li>Set image 명령을 통한 이미지 Rollout  및 확인</li>
<li>kubectl set image deploy nginx-deployment nginx=nginx:1.9.1</li>
<li>kubectl rollout history deploy nginx-deployment</li>
<li>(배포주석 달기)</li>
<li>
<pre style="white-space: pre-wrap">kubectl annotate deploy nginx-deployment kubernetes.io/change-cause="v2 is nginx:1.9.1"</pre>
</li>
<li>kubectl describe po [해당 deployment 의 pod 중 하나의 이름]    # 내용의 image 부분이 1.9.1 인지 확인</li>
<li>(무정지 재배포 히스토리 확인)</li>
<li>kubectl rollout history deploy nginx-deployment</li>
<li>(다음과 같이 출력됨을 확인)<br />
“REVISION  CHANGE-CAUSE<br />
1         v1 is nginx:1.7.9<br />
2         v2 is nginx:1.9.1”</li>
<li>(롤백하기)</li>
<li>kubectl rollout undo deploy nginx-deployment</li>
<li>kubectl rollout undo deploy nginx-deployment --to-revision 5</li>
</ul>
</li>
<li>
<p><b>Lab. Service</b></p>
<ul>
<li>Basic YAML  <pre style="white-space: pre-wrap">
  apiVersion: v1
  kind: Service
  metadata:
    name: my-service
  spec:
    selector:
      app: MyApp
    ports:
      - protocol: TCP
        port: 80
        targetPort: 8080
  </pre>
</li>
<li>kubectl delete service,deploy --all  # 기존 이력 삭제</li>
<li>(다시 생성)</li>
<li>kubectl create deploy nginx --image=nginx</li>
<li>(서비스로 노출)</li>
<li>
<pre style="white-space: pre-wrap">kubectl expose deploy nginx --type="LoadBalancer" --port=80</pre>
</li>
<li>(웹 브라우저를 열고 생성된 external ip 로 접속, Nginx welcome 메시지 확인)</li>
<li>kubectl exec -it (pod name) --/bin/bash   # 생성된 nginx 서버 linux 의 shell 에 접근</li>
</ul>
</li>
<li>
<p><b>Auto Scale-Out </b></p>
<ul>
<li>pwd 로 현 위치가 /container-orchestration/yaml/ 인지 확인</li>
<li>(모든 객체 지우기)</li>
<li>kubectl delete deploy,service,pod --all</li>
<li>(대상 서비스 배포 및 모니터링)</li>
<li>kubectl apply -f <a href="https://k8s.io/examples/application/php-apache.yaml">https://k8s.io/examples/application/php-apache.yaml</a>
<ul>
<li>NOTE : 서비스가 Auto Scaling되기 위해서는 컨테이너 Spec에 Resources : 설정이 있어야 함<br />
&quot;resources:<br />
limits:<br />
cpu: 500m<br />
requests:<br />
cpu: 200m&quot;</li>
</ul>
</li>
<li>(오토 스케일링 설정, hpa: HorizontalPodAutoscaler )
<ul>
<li>kubectl autoscale deployment php-apache --cpu-percent=20 --min=1 --max=10<br />
cpu-percent=50 : Pod 들의 요청 대비 평균 CPU 사용율 (여기서는  요청이 200 milli-cores이므로, 모든 Pod의 평균 CPU 사용율이 100 milli-cores(50%)를 넘게되면 HPA 발생)&quot;</li>
<li>kubectl get hpa php-apache -o yaml</li>
</ul>
</li>
<li>로드 제너레이터(siege)가 설치된 컨테이너 생성
<ul>
<li>cat siege.yaml</li>
<li>kubectl create -f siege.yaml</li>
<li>kubectl exec -it siege --/bin/bash</li>
</ul>
</li>
<li>로드 생성
<ul>
<li>siege -c30 -t30S -v http://php-apache</li>
</ul>
</li>
<li>(오토 스케일링이 되지 않을 때 :  kubectl get hpa의 TARGETS 부분에 cpu 사용률이 <unknown>으로 출력될 때)
<ul>
<li>metrics-server가 제대로 실행중인지 kubectl top pods 명령으로 포드 cpu 사용률이 모니터링 되는지 확인</li>
<li>디플로이먼트의 컨테이너 옵션에 cpu request 옵션이 제대로 걸려 있는지 확인</li>
<li>cpu request옵션이 없으면 hpa가 cpu사용량에 필요한 계산을 할 수 없음</li>
</ul>
</li>
</ul>
</li>
<li>
<p><b>Lab. Volume</b></p>
<ul>
<li>(pwd 로 현 위치가 /container-orchestration/yaml/volume 인지 확인)</li>
<li>(emptyDir 마운트)</li>
<li>kubectl create -f volume-emptydir.yaml</li>
<li>(GitRepository를 볼륨으로 마운트)</li>
<li>kubectl create -f volume-gitrepo.yaml</li>
<li>(PersistentVolumeClaim 생성)</li>
<li>kubectl create -f volume-pvc.yaml</li>
<li>kubectl get pvc</li>
<li>kubectl describe pvc azure-managed-disk</li>
<li>(생성된 PersistentVolueClaim으로 Pod 생성하기)</li>
<li>kubectl create -f pod-with-pvc.yaml</li>
<li>kubectl describe pod mypod</li>
<li>(포드 접속)</li>
<li>kubectl exec -it mypod --/bin/bash</li>
<li>(마운트 및 사이즈 확인)</li>
<li>df -k</li>
</ul>
</li>
<li>
<p><b>Lab. ConfigMap</b></p>
<ul>
<li>(pwd 로 현 위치가 /container-orchestration/yaml/configmap/ 인지 확인)</li>
<li>(컨피그 맵 생성)</li>
<li>kubectl create configmap hello-cm --from-literal=language=java</li>
<li>kubectl get cm</li>
<li>kubectl get cm hello-cm -o yaml</li>
<li>(도커라이징 &amp; ACR Push)
<ul>
<li>az acr build --registry [acr-레지트스리명] --image [acr레지스트리명].azurecr.io/cm-sandbox:v1 .</li>
</ul>
</li>
<li>(인증오류 발생 시, ACR 로그인)
<ul>
<li>az acr login --name (Azure Container Registry 명) --expose-token</li>
<li>Token Expose관련 오류 &gt; expose-token 생략</li>
</ul>
</li>
<li>클라우드에서 배포 이미지 확인</li>
<li>nano cm-deployment.yaml 파일 편집(나의 Registry명으로 수정)</li>
<li>(배포 및 서비스 생성)
<ul>
<li>kubectl create -f cm-deployment.yaml</li>
<li>kubectl create -f cm-service.yaml</li>
</ul>
</li>
<li>(서비스 확인)
<ul>
<li>Service의 External-IP 접속</li>
</ul>
</li>
</ul>
</li>
<li>
<p><b>Lab. Secret</b></p>
<ul>
<li>(pwd 로 현 위치가 /container-orchestration/yaml/secret/ 인지 확인)</li>
<li>(Pod에서 Secret 파일 마운트 사용하기 내용을 참고하여 배포 및 서비스 확인해 보기)</li>
</ul>
</li>
<li>
<p><b>Lab. Liveness &amp; Readiness Probe</b></p>
<ul>
<li>(pwd 로 현 위치가 /container-orchestration/yaml/liveness/ 인지 확인)</li>
<li>(Liveness Command Probe 실습)
<ul>
<li>kubectl create -f exec-liveness.yaml</li>
<li>(컨테이너가 Running 상태로 보이나, Liveness Probe 실패로 계속 재시작)</li>
<li>(kubectl describe로 실패 메시지 확인)</li>
<li>kubectl describe po liveness-exec</li>
</ul>
</li>
<li>(Liveness HTTP Probe 실습)
<ul>
<li>kubectl create -f http-liveness.yaml</li>
<li>(kubectl describe로 실패 메시지 확인)</li>
<li>kubectl describe po liveness-http</li>
</ul>
</li>
<li>(Liveness 와 readiness probe 동시 적용 실습)
<ul>
<li>kubectl create -f tcp-liveness-readiness.yaml</li>
<li>(8080포트에 대해 정상적으로 Liveness 와 readiness Probe를 통과해 서비스가 실행됨)</li>
<li>kubectl describe po goproxy</li>
</ul>
</li>
</ul>
</li>
</ul>
</details>
<details>
<summary><b>Kubernetes Advanced Hands-on</b></summary>
<ul>
<li><b>Lab. Ingress</b>
<ul>
<li>Helm 명령으로 설치 여부 확인</li>
<li>Helm 이 설치되어 있지 않은 경우, Helm(패키지 인스톨러) 설치
<ul>
<li>Helm 3.x 설치(권장)
<ul>
<li>curl <a href="https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3">https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3</a> &gt; get_helm.sh</li>
<li>chmod 700 get_helm.sh</li>
<li>./get_helm.sh</li>
</ul>
</li>
<li>Helm 2.x 설치
<ul>
<li>curl <a href="https://raw.githubusercontent.com/kubernetes/helm/master/scripts/get">https://raw.githubusercontent.com/kubernetes/helm/master/scripts/get</a> | bash</li>
<li>(설치 중, sudo를 위한 비밀번호 입력)</li>
<li>kubectl --namespace kube-system create sa tiller</li>
<li>kubectl create clusterrolebinding tiller --clusterrole cluster-admin --serviceaccount=kube-system:tiller</li>
<li>helm init --service-account tiller</li>
</ul>
</li>
</ul>
</li>
<li>Helm으로 Ingress Controller 설치
<ul>
<li>helm repo add stable <a href="https://charts.helm.sh/stable">https://charts.helm.sh/stable</a></li>
<li>helm repo add ingress-nginx <a href="https://kubernetes.github.io/ingress-nginx">https://kubernetes.github.io/ingress-nginx</a></li>
<li>helm repo update</li>
<li>kubectl create namespace ingress-basic</li>
<li>helm version 확인</li>
<li>(helm version 2.x 일때)
<ul>
<li>helm install --name nginx-ingress stable/nginx-ingress  --namespace=ingress-basic</li>
</ul>
</li>
<li>(helm version 3.x 일때)
<ul>
<li>helm install nginx-ingress ingress-nginx/ingress-nginx --namespace=ingress-basic</li>
</ul>
</li>
<li>(설치확인)
<ul>
<li>kubectl get all --namespace=ingress-basic</li>
<li>(Ingress Controller의 EXTERNAL-IP가 API Gateway 엔드포인트: 메모 必)</li>
</ul>
</li>
</ul>
</li>
<li>Ingress 대상 서비스(BLUE, GREEN) 생성
<ul>
<li>(pwd 로 현 위치가 /container-orchestration/yaml/ingress/blue-svc/ 인지 확인)
<ul>
<li>(도커라이징 &amp; 이미지 Push)</li>
<li>az acr build --registry [acr-레지트스리명] --image [acr레지스트리명].azurecr.io/nginx-blue:latest .</li>
<li>(배포 전 yaml을 열어 image URL을 나의 ACR이름으로 수정)</li>
<li>nano nginx-blue-deployment.yaml</li>
<li>(저장 ctrl + X)</li>
<li>(배포 및 서비스 생성)</li>
<li>kubectl create -f nginx-blue-deployment.yaml</li>
</ul>
</li>
<li>(pwd 로 현 위치가 /container-orchestration/yaml/ingress/green-svc/ 인지 확인)
<ul>
<li>(도커라이징 &amp; 이미지 Push)</li>
<li>az acr build --registry [acr-레지트스리명] --image [acr레지스트리명].azurecr.io/nginx-green:latest .</li>
<li>(배포 전 yaml을 열어 image URL을 나의 ACR이름으로 수정)</li>
<li>nano nginx-green-deployment.yaml</li>
<li>(저장 ctrl + X)</li>
<li>(배포 및 서비스 생성)</li>
<li>kubectl create -f nginx-green-deployment.yaml</li>
</ul>
</li>
<li>(서비스 생성 확인)
<ul>
<li>kubectl get deploy,service -n ingress-basic</li>
</ul>
</li>
</ul>
</li>
<li>Ingress Routing Rule 생성
<ul>
<li>(pwd 로 현 위치가 /container-orchestration/yaml/ingress/ 인지 확인)</li>
<li>kubectl create -f path-based-ingress.yaml</li>
<li>kubectl get ingress -n ingress-basic</li>
</ul>
</li>
<li>Ingress 테스트
<ul>
<li>인그레이스 리소스 삭제</li>
<li>kubectl delete namespace ingress-basic</li>
</ul>
</li>
</ul>
</li>
<li><b>Azure AKS 모니터링</b>
<ul>
<li>admin-user 서비스 계정 및 클러스터 롤 바인딩 생성 <pre style="white-space: pre-wrap">
    cat &#60;&#60;EOF | kubectl apply -f -
      &#45;&#45;&#45;
      apiVersion: v1
      kind: ServiceAccount
      metadata:
        name: admin-user
        namespace: kube-system
      &#45;&#45;&#45;
      apiVersion: rbac.authorization.k8s.io/v1beta1
      kind: ClusterRoleBinding
      metadata:
        name: admin-user
      roleRef:
        apiGroup: rbac.authorization.k8s.io
        kind: ClusterRole
        name: cluster-admin
      subjects:
      - kind: ServiceAccount
        name: admin-user
        namespace: kube-system
    EOF
   </pre>
</li>
<li>인증 토큰 조회
<ul>
<li>
<pre style="white-space: pre-wrap">kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin-user | awk "{print $1}")</pre>
</li>
</ul>
</li>
<li>az aks browse --resource-group (resource-group-name) --name (cluster-name)</li>
<li>복사된 토큰값 붙여넣기 및 로그인</li>
</ul>
</li>
</ul>
 </details>
 <details>
<summary><b>Real MSA Application Deployment</b></summary>
<ul>
<li>
<p><b>사전작업</b></p>
<ul>
<li>az acr login --name [acr-repository-name] --expose-token</li>
<li>cd  ~</li>
<li>mkdir MSA-Sample</li>
<li>cd MSA-Sample</li>
</ul>
</li>
<li>
<p><b>마이크로서비스 배포</b></p>
<ul>
<li>
<p>상품(Product) 서비스</p>
<pre style="white-space: pre-wrap">
git clone https://github.com/event-storming/reqres_products.git
cd reqres_products
<p>mvn package -Dmaven.test.skip=true</p>
<p>az acr build --registry (myregistry) --image (myregistry).azurecr.io/products:latest .</p>
<p>kubectl create deploy products --image=(myregistry).azurecr.io/products:latest<br />
kubectl expose deploy products --type=ClusterIP&quot; --port=8080</p>
<p>cd …</p>
</pre>
</li>
<li>
<p>여러 서비스를 편하게 배포하기 위해 Container Registry를 환경변수로 설정</p>
<ul>
<li>export CRNAME=(myregistry)</li>
<li>export ACR=${CRNAME}.azurecr.io</li>
</ul>
</li>
<li>
<p>주문(Order) 서비스</p>
<pre style="white-space: pre-wrap">
git clone https://github.com/event-storming/reqres_orders.git
cd reqres_orders
export IMAGENAME=orders
<p>mvn package -Dmaven.test.skip=true<br />
az acr build --registry ${CRNAME} --image <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>A</mi><mi>C</mi><mi>R</mi></mrow><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">{ACR}/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit">A</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span><span class="mord mathrm">/</span></span></span></span>{IMAGENAME}:latest .<br />
kubectl create deploy {IMAGENAME} --image={ACR}/${IMAGENAME}:latest<br />
kubectl expose deploy ${IMAGENAME} --type=ClusterIP&quot; --port=8080</p>
<p>cd …</p>
</pre>
</li>
<li>
<p>배송(Delivery) 서비스</p>
<pre style="white-space: pre-wrap">
git clone https://github.com/event-storming/reqres_delivery.git
cd reqres_delivery
export IMAGENAME=delivery
<p>mvn package -Dmaven.test.skip=true<br />
az acr build --registry ${CRNAME} --image <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>A</mi><mi>C</mi><mi>R</mi></mrow><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">{ACR}/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit">A</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span><span class="mord mathrm">/</span></span></span></span>{IMAGENAME}:latest .<br />
kubectl create deploy {IMAGENAME} --image={ACR}/${IMAGENAME}:latest<br />
kubectl expose deploy ${IMAGENAME} --type=ClusterIP&quot; --port=8080</p>
<p>cd …</p>
</pre>
</li>
<li>
<p>인증(Oauth) 서비스</p>
<pre style="white-space: pre-wrap">
git clone https://github.com/event-storming/oauth.git
cd oauth
export IMAGENAME=oauth
<p>mvn package -Dmaven.test.skip=true<br />
az acr build --registry ${CRNAME} --image <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>A</mi><mi>C</mi><mi>R</mi></mrow><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">{ACR}/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit">A</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span><span class="mord mathrm">/</span></span></span></span>{IMAGENAME}:latest .<br />
kubectl create deploy {IMAGENAME} --image={ACR}/${IMAGENAME}:latest<br />
kubectl expose deploy ${IMAGENAME} --type=ClusterIP&quot; --port=8080</p>
<p>cd …</p>
</pre>
</li>
<li>
<p>게이트웨이(Gateway) 서비스</p>
<pre style="white-space: pre-wrap">
git clone https://github.com/event-storming/gateway.git
cd gateway
export IMAGENAME=gateway
<p>mvn package -Dmaven.test.skip=true<br />
az acr build --registry ${CRNAME} --image <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>A</mi><mi>C</mi><mi>R</mi></mrow><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">{ACR}/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit">A</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span><span class="mord mathrm">/</span></span></span></span>{IMAGENAME}:latest .<br />
kubectl create deploy {IMAGENAME} --image={ACR}/${IMAGENAME}:latest<br />
kubectl expose deploy ${IMAGENAME} --type=“LoadBalancer” --port=8080</p>
<p>cd …</p>
</pre>
</li>
<li>
<p>프론트-엔드(UI) 서비스 빌드를 위한 npm 설치 (Azure Cloud에서 실행시 Skip)</p>
<pre style="white-space: pre-wrap">
sudo apt-get update
sudo apt install build-essential
curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -
sudo apt install nodejs
</pre>
</li>
<li>
<p>프론트-엔드(UI) 서비스: 배포 사전 작업</p>
<pre style="white-space: pre-wrap">
git clone https://github.com/event-storming/ui.git
cd ui
export IMAGENAME=ui
<p>npm install<br />
npm run build<br />
az acr build --registry ${CRNAME} --image <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>A</mi><mi>C</mi><mi>R</mi></mrow><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">{ACR}/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit">A</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span><span class="mord mathrm">/</span></span></span></span>{IMAGENAME}:latest .</p>
<p>_GATEWAY_IP=$(kubectl get -o jsonpath=&quot;{.status.loadBalancer.ingress[0].ip}&quot; svc gateway --ignore-not-found)<br />
echo ${_GATEWAY_IP}</p>
</pre>
</li>
<li>
<p>프론트-엔드(UI) 서비스:  배포 및 서비스 생성</p>
<pre style="white-space: pre-wrap">
cat &#60;&#60;EOF | kubectl apply -f -
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ${IMAGENAME}
  labels:
    app: ${IMAGENAME}
spec:
  replicas: 1
  selector:
    matchLabels:
      app: ${IMAGENAME}
  template:
    metadata:
      labels:
        app: ${IMAGENAME}
    spec:
      containers:
        - name: ${IMAGENAME}
          image: ${ACR}/${IMAGENAME}:latest
          ports:
            - containerPort: 8080
          env:
            - name: VUE_APP_API_HOST
              value: http://${_GATEWAY_IP}:8080
EOF
<p>kubectl expose deploy ${IMAGENAME} --type=“LoadBalancer” --port=8080</p>
<p>cd …</p>
</pre>
</li>
</ul>
</li>
<li>
<p><b>서비스 확인</b></p>
<ul>
<li>kubectl get svc ui</li>
<li>브라우저에서 접속 http://UI-Service-EXTERNAL-IP:8080</li>
</ul>
</li>
</ul>
 </details>
 <details>
<summary><b>Service Mesh, Istio Hands-on</b></summary>
<ul>
<li>
<p><b>Lab. Istio Install</b></p>
<ul>
<li>Istio 설치</li>
<li>curl -L <a href="https://istio.io/downloadIstio">https://istio.io/downloadIstio</a> | ISTIO_VERSION=1.7.1 TARGET_ARCH=x86_64 sh -<br />
&quot;(istio v1.7.1은 Kubernetes 1.16이상에서만 동작)&quot;</li>
<li>cd istio-1.7.1</li>
<li>
<pre style="white-space: pre-wrap">export PATH=$PWD/bin:$PATH</pre>
</li>
<li>istioctl install --set profile=demo --set <a href="http://hub=gcr.io/istio-release">hub=gcr.io/istio-release</a><br />
&quot;note : there are other profiles for production or performance testing.&quot;</li>
<li>Istio 모니터링 툴(Telemetry Applications) 설치
<ul>
<li>
<p>vi samples/addons/kiali.yaml</p>
</li>
<li>
<p>4라인의 apiVersion: <a href="http://apiextensions.k8s.io/v1beta1%EC%9D%84">apiextensions.k8s.io/v1beta1을</a> apiVersion: <a href="http://apiextensions.k8s.io/v1%EC%9C%BC%EB%A1%9C">apiextensions.k8s.io/v1으로</a> 수정</p>
</li>
<li>
<p>kubectl apply -f samples/addons</p>
</li>
<li>
<p>kiali.yaml 오류발생시, 아래 명령어 실행</p>
<blockquote>
<p>kubectl apply -f <a href="https://raw.githubusercontent.com/istio/istio/release-1.7/samples/addons/kiali.yaml">https://raw.githubusercontent.com/istio/istio/release-1.7/samples/addons/kiali.yaml</a></p>
</blockquote>
</li>
<li>
<p>모니터링(Tracing &amp; Monitoring) 툴 설정</p>
<ul>
<li>Monitoring Server - Kiali
<ul>
<li>기본 ServiceType 변경 : ClusterIP를 LoadBalancer 로…
<ul>
<li>kubectl edit svc kiali -n istio-system</li>
<li>:%s/ClusterIP/LoadBalancer/g</li>
<li>:wq!</li>
</ul>
</li>
<li>모니터링 시스템(kiali) 접속 : EXTERNAL-IP:20001 (admin/admin)</li>
</ul>
</li>
<li>Tracing Server - Jaeger
<ul>
<li>기본 ServiceType 변경 : ClusterIP를 LoadBalancer 로…
<ul>
<li>kubectl edit svc tracing -n istio-system</li>
<li>:%s/ClusterIP/LoadBalancer/g</li>
<li>:wq!</li>
</ul>
</li>
<li>분산추적 시스템(tracing) 접속 : EXTERNAL-IP:80</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>설치확인
<ul>
<li>kubectl get all -n istio-system</li>
</ul>
</li>
</ul>
</li>
<li>
<p><b>How to enable Istio</b></p>
<ul>
<li>
<ol>
<li>Whenever deploying to Cluster, Using pre-processing command “Istio kube-inject”</li>
</ol>
<ul>
<li>kubectl apply -f &lt;(istioctl kube-inject -f Deployment.yml) -n istio-test-ns</li>
</ul>
</li>
<li>
<ol start="2">
<li>Using Istio-enabled Namespace.</li>
</ol>
<ul>
<li>e.g. kubectl label namespace tutorial istio-injection=enabled</li>
</ul>
</li>
</ul>
</li>
<li>
<p><b>Lab. Istio Tutorial 셋업</b></p>
<ul>
<li>Git repository에서 Tutorial 리소스 가져오기
<ul>
<li>cd ~</li>
<li>mkdir git</li>
<li>cd git</li>
<li>git clone <a href="https://github.com/redhat-developer-demos/istio-tutorial">https://github.com/redhat-developer-demos/istio-tutorial</a></li>
<li>cd istio-tutorial</li>
</ul>
</li>
<li>네임스페이스 생성
<ul>
<li>kubectl create namespace tutorial</li>
</ul>
</li>
<li>Customer Service 배포
<ul>
<li>kubectl apply -f &lt;(istioctl kube-inject -f customer/kubernetes/Deployment.yml) -n tutorial
<ul>
<li>kubectl describe pod (Customer Pod) -n tutorial 로 생성확인</li>
</ul>
</li>
<li>kubectl create -f customer/kubernetes/Service.yml -n tutorial</li>
</ul>
</li>
<li>Istio Gateway 설치 및 Customer 서비스 라우팅(VirtualService) 설정
<ul>
<li>cat customer/kubernetes/Gateway.yml</li>
<li>kubectl create -f customer/kubernetes/Gateway.yml -n tutorial</li>
<li>(Istio-IngressGateway를 통한 Customer 서비스 확인)
<ul>
<li>kubectl get service/istio-ingressgateway -n istio-system</li>
<li>해당 EXTERNAL-IP가 Istio Gateway 주소</li>
<li>Customer 서비스 호출 :<pre style="white-space: pre-wrap">"http://(istio-ingressgateway IP)/customer"</pre>
</li>
</ul>
</li>
</ul>
</li>
<li>Preference, Recommendation-v1 Service 배포
<ul>
<li>kubectl apply -f &lt;(istioctl kube-inject -f preference/kubernetes/Deployment.yml)  -n tutorial</li>
<li>kubectl create -f preference/kubernetes/Service.yml -n tutorial</li>
<li>kubectl apply -f &lt;(istioctl kube-inject -f recommendation/kubernetes/Deployment.yml) -n tutorial</li>
<li>kubectl create -f recommendation/kubernetes/Service.yml -n tutorial</li>
</ul>
</li>
</ul>
</li>
<li>
<p><b>Lab. Istio - Traffic Routing</b></p>
<ul>
<li>Simple Routing
<ul>
<li>
<p>(pwd 로 현 위치가 /istio-tutorial/ 인지 확인)</p>
</li>
<li>
<p>(recommendation 서비스 추가 배포: v2)</p>
<ul>
<li>kubectl apply -f &lt;(istioctl kube-inject -f recommendation/kubernetes/Deployment-v2.yml) -n tutorial</li>
</ul>
</li>
<li>
<p>서비스 호출</p>
<ul>
<li>브라우저에서 Customer 서비스(Externl-IP:8080 접속) 호출</li>
<li>F5(새로고침)를 10회 이상 클릭하여 다수의 요청 생성</li>
</ul>
</li>
<li>
<p>Routing 결과 확인 - Kiali(Externl-IP:20001) 접속</p>
</li>
<li>
<p>(Recommendation v.2 서비스 Scale Out)</p>
</li>
<li>
<p>(서비스의 v2 의 replica 를 2로 설정)</p>
<ul>
<li>kubectl scale --replicas=2 deployment/recommendation-v2 -n tutorial</li>
<li>kubectl get po -n tutorial</li>
</ul>
</li>
<li>
<p>Customer 서비스를 10회 이상 F5(새로고침)하여 서비스 호출</p>
</li>
<li>
<p>Routing 결과 확인 - Kiali(Externl-IP:20001) 접속</p>
</li>
</ul>
</li>
<li>Advanced Routing
<ul>
<li>정책(VirtualService, DestinationRule) 설정
<ul>
<li>(현, 정책 확인)
<ul>
<li>kubectl get VirtualService -n tutorial -o yaml</li>
<li>kubectl get DestinationRule -n tutorial -o yaml</li>
</ul>
</li>
<li>(사용자 선호도에 따른 추천 서비스 라우팅 정책 설정)</li>
<li>(VirtualService, DestinationRule 설정, v2로 100% 라우팅)
<ul>
<li>kubectl create -f istiofiles/destination-rule-recommendation-v1-v2.yml -n tutorial</li>
<li>kubectl create -f istiofiles/virtual-service-recommendation-v2.yml -n tutorial</li>
</ul>
</li>
<li>(설정정책 확인)
<ul>
<li>kubectl get VirtualService -n tutorial -o yaml</li>
<li>kubectl get DestinationRule -n tutorial -o yaml</li>
</ul>
</li>
<li>(서비스 확인)
<ul>
<li>브라우저에서 Customer 서비스(Externl-IP:8080 접속)호출</li>
<li>Kiali(Externl-IP:20001), Jaeger(External-IP:80)에서 모니터링</li>
</ul>
</li>
</ul>
</li>
<li>가중치 기반 스마트 라우팅 (Canary Deployment)
<ul>
<li>(recommendation 서비스 v1의 가중치를 100으로 변경)
<ul>
<li>kubectl replace -f istiofiles/virtual-service-recommendation-v1.yml -n tutorial</li>
</ul>
</li>
<li>(서비스 호출 및 Kiali(Externl-IP:20001)에서 모니터링)</li>
<li>(VirtualService 삭제 시, Round-Robin 방식으로 동작)
<ul>
<li>kubectl delete -f istiofiles/virtual-service-recommendation-v1.yml -n tutorial</li>
</ul>
</li>
<li>Canary 라우팅 비율별 배포 정책 예시
<ul>
<li>(90 : 10)</li>
<li>kubectl apply -f istiofiles/virtual-service-recommendation-v1_and_v2.yml -n tutorial</li>
<li>(75 : 25)</li>
<li>kubectl replace -f istiofiles/virtual-service-recommendation-v1_and_v2_75_25.yml -n tutorial</li>
</ul>
</li>
<li>삭제
<ul>
<li>kubectl delete dr recommendation -n tutorial</li>
<li>#kubectl delete vs recommendation -n tutorial</li>
<li>kubectl scale --replicas=1 deployment/recommendation-v2 -n tutorial</li>
</ul>
</li>
</ul>
</li>
<li>Client 브라우저 유형별 스마트 라우팅
<ul>
<li>Firefox 브라우저로 접속 시, v2로 라우팅되도록 설정
<ul>
<li>kubectl apply -f istiofiles/destination-rule-recommendation-v1-v2.yml -n tutorial</li>
<li>kubectl apply -f istiofiles/virtual-service-firefox-recommendation-v2.yml -n tutorial</li>
</ul>
</li>
<li>(Firefox 브라우저와 다른 브라우저에서 접속 확인)</li>
<li>(Browser 환경이 지원되지 않을 경우,)
<ul>
<li>curl -A Safari Externl-IP:8080</li>
<li>curl -A Firefox Externl-IP:8080</li>
</ul>
</li>
<li>삭제
<ul>
<li>kubectl delete dr recommendation -n tutorial</li>
<li>kubectl delete vs recommendation -n tutorial</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><b>Lab. Istio - Timeout &amp; Retry</b></p>
<ul>
<li>Lab에 필요한 모듈(Message Queue) 설치
<ul>
<li>kubectl get svc my-kafka -n kafka</li>
<li>미설치시, 설치 링크 (<a href="https://workflowy.com/s/msa/27a0ioMCzlpV04Ib#/a7018fb8c629">https://workflowy.com/s/msa/27a0ioMCzlpV04Ib#/a7018fb8c629</a>)</li>
</ul>
</li>
<li>tutorial  네임스페이스에 Istio 기능 추가
<ul>
<li>kubectl label namespace tutorial istio-injection=enabled --overwrite</li>
<li>네임스페이스가 없을 시, 생성 후 실행</li>
</ul>
</li>
<li>Lab. Timeout : Fail-Fast를 통한 서비스 Caller 자원 보호
<ul>
<li>Timeout 테스트를 위해 CNA 과정에서 구현한 Order 마이크로서비스의  코드 보완 및 tutorial 네임스페이스에 배포
<ul>
<li>Service time delay를 위해, Order Aggregate(Order.java)에 저장전 Thread.sleep 코드 삽입<pre style="white-space: pre-wrap">
@PrePersist
    public void onPrePersist(){
  try {
      Thread.currentThread().sleep((long) (800 + Math.random() * 220));
  } catch (InterruptedException e) {
      e.printStackTrace();
  }
}
</pre>
</li>
<li>Docker image Build &amp; Push</li>
<li>tutorial 네임스페이스에 Order 서비스 배포  <pre style="white-space: pre-wrap">
  kubectl apply -f - &#60;&#60;EOF
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: order
    namespace: tutorial
    labels:
      app: order
  spec:
    replicas: 1
    selector:
      matchLabels:
        app: order
    template:
      metadata:
        labels:
          app: order
      spec:
        containers:
          - name: order
            image: IMAGE_FULL_REPOSITORY_URL/order:v2
            ports:
              - containerPort: 8080
            resources:
              limits:
                cpu: 500m
              requests:
                cpu: 200m
  EOF
  </pre>
</li>
<li>Order 서비스 생성
<ul>
<li>kubectl expose deploy order --port=8080 -n tutorial</li>
</ul>
</li>
<li>Order 서비스 Timeout 설정 (Istio Gateway에서 Order 서비스로 라우팅 시)
<ul>
<li>(pwd 로 현 위치가 /istio-tutorial/ 인지 확인)</li>
<li>nano customer/kubernetes/Gateway.yaml 오픈 후 마지막 행 다음에 타임아웃 설정이 포함된 아래 내용 추가<pre style="white-space: pre-wrap">
- match:
    - uri:
        prefix: /orders
    route:
    - destination:
        host: order
        port:
          number: 8080
    timeout: 3s
</pre>
</li>
<li>(변경 내용 적용)</li>
<li>kubectl apply -f customer/kubernetes/Gateway.yml -n tutorial</li>
</ul>
</li>
<li>Order 서비스 Timeout 설정 (클라우드 내에서 Order 서비스로 라우팅시)<pre style="white-space: pre-wrap">
kubectl apply -f - &#60;&#60;EOF
    apiVersion: networking.istio.io/v1alpha3
    kind: VirtualService
    metadata:
      name: vs-order-network-rule
      namespace: tutorial
    spec:
      hosts:
      - order
      http:
      - route:
        - destination:
            host: order
        timeout: 3s
EOF
</pre>
</li>
<li>부하테스트 툴(Siege) 설치 및 Order 서비스 Load Testing
<ul>
<li>kubectl run siege --image=apexacme/siege-nginx -n tutorial</li>
<li>kubectl exec -it siege -c siege -n tutorial -- /bin/bash</li>
<li>
<pre style="white-space: pre-wrap">siege -c30 -t20S -v --content-type "application/json" 'http://order:8080/orders POST {"productId": "1001", "qty":5}'</pre>
</li>
</ul>
</li>
</ul>
</li>
<li>Order 서비스에 설정된 Timeout을 임계치를 초과하는 순간, Istio에서 서비스로의 연결을 자동 차단하는 것을 확인</li>
</ul>
</li>
<li>Lab. Retry : 5xx 오류를 리턴받게 되면, Envoy Proxy에서 설정한 횟수만큼 대상 서비스를 재호출하여 일시적인 장애였는지를 다시 확인하는 Rule
<ul>
<li>Retry 테스트를 위해 CNA 과정에서 구현한 Delivery 마이크로서비스를 tutorial 네임스페이스에 배포</li>
<li>Docker image Build &amp; Push</li>
<li>tutorial 네임스페이스에 Delivery 서비스 배포<pre style="white-space: pre-wrap">
kubectl apply -f - &#60;&#60;EOF
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: delivery
    namespace: tutorial
    labels:
      app: delivery
  spec:
    replicas: 1
    selector:
      matchLabels:
        app: delivery
    template:
      metadata:
        labels:
          app: delivery
      spec:
        containers:
          - name: delivery
            image: IMAGE_FULL_REPOSITORY_URL/delivery:v1
            ports:
              - containerPort: 8080
            resources:
              limits:
                cpu: 500m
              requests:
                cpu: 200m
EOF
</pre>
</li>
<li>Delivery 서비스 생성
<ul>
<li>kubectl expose deploy delivery --port=8080 -n tutorial</li>
</ul>
</li>
<li>Order 서비스에 Retry Rule 추가 적용<pre style="white-space: pre-wrap">
kubectl apply -f - &#60;&#60;EOF
  apiVersion: networking.istio.io/v1alpha3
  kind: VirtualService
  metadata:
    name: vs-order-network-rule
    namespace: tutorial
  spec:
    hosts:
    - order
    http:
    - route:
      - destination:
          host: order
      timeout: 3s
      retries:
        attempts: 3
        perTryTimeout: 2s
        retryOn: 5xx,retriable-4xx,gateway-error,connect-failure,refused-stream
EOF
</pre>
</li>
<li>Delivery 서비스를 정지하고, 이를 동기호출하는 Order 서비스 API 호출
<ul>
<li>kubectl scale deploy delivery --replicas=0 -n tutorial</li>
<li>kubectl exec -it siege -c siege -n tutorial --/bin/bash</li>
<li>http <a href="http://order:8080/orders/">http://order:8080/orders/</a> productId=1001 qty=5
<ul>
<li>httpie가 없을 시,</li>
<li>apt-get update</li>
<li>apt-get install httpie</li>
</ul>
</li>
<li>http DELETE <a href="http://order:8080/orders/1">http://order:8080/orders/1</a></li>
</ul>
</li>
<li>Jaeger 접속(<a href="http://tracing">http://tracing</a> svc EXTERNAL-IP :80) 후, Retry 횟수 확인하기<br />
&quot;&lt; 검색조건 &gt;<br />
Service : order.tutorial, Operation : delivery.tutorial.svc.cluster.local:8080/*<br />
검색결과 : 총 Retry 횟수 + 1 의 Requests 로깅&quot;</li>
</ul>
</li>
</ul>
</li>
<li>
<p><b>Lab. Istio - Circuit Breaker</b></p>
<ul>
<li>Circuit Breaker : 장애 인스턴스를 회피하는 기능으로 5xx 오류를 리턴한 인스턴스를  라우팅 대상에서 일정시간 만큼 제외 (Pool Ejection)</li>
<li>Namespace 생성 및 Istio 활성
<ul>
<li>kubectl create namespace istio-cb-ns</li>
<li>kubectl label namespace istio-cb-ns istio-injection=enabled</li>
</ul>
</li>
<li>Istio Retry 디폴트 동작 확인
<ul>
<li>테스트 어플리케이션 배포
<ul>
<li>hello-server-1, hello-server-2 Pods, Service</li>
<li>hello-server 앱은 env:RANDOM_ERROR 값의 확률로 랜덤하게 503 에러를 발생하는 로직이 포함<pre style="white-space: pre-wrap">
kubectl apply -f - &#60;&#60;EOF
    apiVersion: v1
    kind: Pod
    metadata:
      name: hello-server-1
      namespace: istio-cb-ns
      labels:
        app: hello
    spec:
      containers:
      - name: hello-server-1
        image: docker.io/honester/hello-server:latest
        imagePullPolicy: IfNotPresent
        env:
        - name: VERSION
          value: "v1"
        - name: LOG
          value: "1"
    &#45;&#45;&#45;
    apiVersion: v1
    kind: Pod
    metadata:
      name: hello-server-2
      namespace: istio-cb-ns
      labels:
        app: hello
    spec:
      containers:
      - name: hello-server-2
        image: docker.io/honester/hello-server:latest
        imagePullPolicy: IfNotPresent
        env:
        - name: VERSION
          value: "v2"
        - name: LOG
          value: "1"
        - name: RANDOM_ERROR
          value: "0.2"
    &#45;&#45;&#45;
    apiVersion: v1
    kind: Service
    metadata:
      name: svc-hello
      namespace: istio-cb-ns
      labels:
        app: hello
    spec:
      selector:
        app: hello
      ports:
      - name: http
        protocol: TCP
        port: 8080
EOF
</pre>
</li>
<li>클라이언트용 서비스(httpbin) 배포<pre style="white-space: pre-wrap">
kubectl apply -f - &#60;&#60;EOF
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: httpbin
      namespace: istio-cb-ns
    spec:
      replicas: 1
      selector:
        matchLabels:
          app: httpbin
      template:
        metadata:
          labels:
            app: httpbin
        spec:
          containers:
          - name: httpbin
            image: docker.io/honester/httpbin:latest
            imagePullPolicy: IfNotPresent
            ports:
            - containerPort: 80
    &#45;&#45;&#45;
    apiVersion: v1
    kind: Service
    metadata:
      name: httpbin
      namespace: istio-cb-ns
      labels:
        app: httpbin
    spec:
      selector:
        app: httpbin
      ports:
      - name: http
        port: 8000
        targetPort: 80
EOF
</pre>
</li>
</ul>
</li>
<li>Retry 디폴트 동작 테스트
<ul>
<li>hello-server-2의 로그 모니터 걸기
<ul>
<li>kubectl logs -f hello-server-2 -c hello-server-2 -n istio-cb-ns</li>
</ul>
</li>
<li>클라이언트에서 svc-hello 서비스 10번 호출하기
<ul>
<li>for i in {1…10}; do kubectl exec -it httpbin -c httpbin -n istio-cb-ns --curl http://svc-hello.istio-cb-ns:8080; sleep 0.1; done</li>
</ul>
</li>
</ul>
</li>
<li>결과 확인/분석<br />
&quot;1) 서비스 호출은 Round Robin으로 로드 밸런싱되나, 프로세싱 시간에 따라 동일한 서비스가 연속 2회 로깅 될 수 있음
<ol start="2">
<li>핵심포인트는, Server-2가 5xx 오류를 리턴할 경우, 자동으로 Retry되어 Server-1 로그가 연달아 출력된다는 점임. (Default Retry : 2회)&quot;</li>
</ol>
</li>
</ul>
</li>
<li>Circuit Breaker 설정
<ul>
<li>대기 쓰레드수 기반 Circuit Breaker
<ul>
<li>클라이언트용 서비스(httpbin)에 쓰레드 기반 Circuit Breaker 설정</li>
<li>(Pending Thread가 많을수록 경우, 오랫동안 큐잉된 요청은 Response time이 증가하게 되므로, 적절한 대기 쓰레드를 풀을 적용하여 Circuit Breaking)<pre style="white-space: pre-wrap">
kubectl apply -f - &#60;&#60;EOF
  apiVersion: networking.istio.io/v1alpha3
  kind: DestinationRule
  metadata:
    name: dr-httpbin
    namespace: istio-cb-ns
  spec:
    host: httpbin
    trafficPolicy:
      connectionPool:
        http:
          http1MaxPendingRequests: 1
          maxRequestsPerConnection: 1
EOF
</pre>
</li>
<li>Circuit Breaker 동작 확인
<ul>
<li>부하테스트 툴(Siege) 설치 및  Load Testing
<ul>
<li>kubectl run siege --image=apexacme/siege-nginx -n istio-cb-ns</li>
<li>kubectl exec -it siege -c siege -n istio-cb-ns --/bin/bash
<ul>
<li>siege -c1 -t10S -v <a href="http://httpbin:8000/get">http://httpbin:8000/get</a>  # 100% availability</li>
<li>siege -c2 -t10S -v <a href="http://httpbin:8000/get">http://httpbin:8000/get</a>  # 87% availability</li>
</ul>
</li>
</ul>
</li>
<li>Kiali(Externl-IP:20001) 모니터링</li>
</ul>
</li>
</ul>
</li>
<li>로드 밸런싱 풀(pool) 인스턴스의 Health Status 기반 Circuit Breaker
<ul>
<li>Hello 서비스의 로드 밸런싱 풀(pool)의 인스턴스 상태기반 Circuit Breaker 설정<pre style="white-space: pre-wrap">
kubectl apply -f - &#60;&#60;EOF
  apiVersion: networking.istio.io/v1alpha3
  kind: DestinationRule
  metadata:
    name: dr-hello-server
    namespace: istio-cb-ns
  spec:
    host: svc-hello
    trafficPolicy:
      outlierDetection:
        interval: 1s
        consecutiveErrors: 1
        baseEjectionTime: 3m
        maxEjectionPercent: 100
EOF
</pre>
</li>
<li>Circuit Breaker 동작 확인
<ul>
<li>클라이언트(httpbin Pod)에서 svc-hello 호출
<ul>
<li>hello-server-2의 로그 모니터 걸기
<ul>
<li>kubectl logs -f hello-server-2 -c hello-server-2 -n istio-cb-ns</li>
</ul>
</li>
<li>클라이언트에서 svc-hello 서비스 10번 호출하기
<ul>
<li>for i in {1…10}; do kubectl exec -it httpbin -c httpbin -n istio-cb-ns --curl http://svc-hello.istio-cb-ns:8080; sleep 0.1; done</li>
</ul>
</li>
<li>결과 확인/분석<br />
&quot;1) 5초 동안 5xx 에러가 2번 발생할 경우, Server-2로는 5분 동안 트래픽이 라우팅 되지 않는다.
<ol start="2">
<li>모니터링 시스템(Kiali) : EXTERNAL-IP:20001 에서 Circuit Breaker 뱃지 발생 확인&quot;</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>동기호출 Target인 배송(Delivery) 서비스에 Circuit Breaker 설정하기
<ul>
<li>Thread 부하 및 5XX 오류에 대해 서비스를 차단하는 Circuit Breaker 생성<pre style="white-space: pre-wrap">
kubectl apply -f - &#60;&#60;EOF
  apiVersion: networking.istio.io/v1alpha3
  kind: DestinationRule
  metadata:
    name: dr-delivery
    namespace: tutorial
  spec:
    host: delivery
    trafficPolicy:
      connectionPool:
        http:
          http1MaxPendingRequests: 1
          maxRequestsPerConnection: 1
      outlierDetection:
        interval: 5s
        consecutiveErrors: 1
        baseEjectionTime: 5m
        maxEjectionPercent: 100
EOF
</pre>
</li>
<li>설정 내용
<ul>
<li>최대 활성 연결 갯수 30개와 최대 요청 대기 수를 100개로 지정하고, 이 임계점을 넘어가는 추가 요청은 거부(circuit break)</li>
<li>5초 동안 2번 5xx을 리턴한 서비스는 5분 동안 라우팅 대상에서 제외(Ejection)</li>
<li>또한, 모든 대상 서비스 인스턴스가 방출(제외)될 수 있음</li>
</ul>
</li>
</ul>
</li>
<li>Clean-up
<ul>
<li>kubectl delete pod/hello-server-1 pod/hello-server-2 pod/httpbin service/svc-hello dr/dr-hello -n istio-cb-ns</li>
</ul>
</li>
</ul>
</li>
<li>
<p><b>Clear Istio </b></p>
<ul>
<li>kubectl delete ns tutorial istio-cb-ns istio-system</li>
</ul>
</li>
</ul>
 </details>
 <details>
<summary><b>Backup</b></summary>
<ul>
<li>
<p><b>Container로부터 이미지 생성</b></p>
<ul>
<li>
<p>이미지 생성</p>
<ul>
<li>docker run --name my-nginx -d -p 80:80 nginx</li>
<li>docker exec -it my-nginx /bin/bash
<ul>
<li>apt-get update</li>
<li>apt-get install curl</li>
<li>cd /usr/share/nginx/html</li>
<li>
<pre style="white-space: pre-wrap">echo "Hello my name is PYJ." >> index.html</pre>
</li>
<li>exit</li>
</ul>
</li>
<li>docker commit my-nginx my-nginx:1.0 # 컨테이너를 이미지로 생성</li>
<li>docker diff [실행중인 Container ID] #원본 이미지와의 차이점 확인</li>
<li>docker commit -a <a href="mailto:%22apex@naver.com">&quot;apex@naver.com</a>&quot; -m “update nginx” my-nginx my-nginx:1.0</li>
<li>docker images</li>
<li>docker stop my-nginx</li>
<li>docker run --name my-nginx2 -p 80:80 -d my-nginx:1.0</li>
<li><a href="http://localhost">http://localhost</a> 확인</li>
<li>docker stop my-nginx2</li>
</ul>
</li>
<li>
<p>이미지 푸시</p>
<ul>
<li>docker tag my-nginx:1.0 apexacme/my-nginx:1.0</li>
<li>docker images</li>
<li>docker push apexacme/my-nginx:1.0</li>
<li><a href="http://hub.docker.com">http://hub.docker.com</a> 에서 이미지 확인</li>
</ul>
</li>
<li>
<p>도커허브 이미지로부터 컨테이너 실행</p>
<ul>
<li>docker run --name new-nginx -d -p 80:80 apexacme/my-nginx:1.0</li>
</ul>
</li>
</ul>
</li>
<li>
<p><b>샘플 자바 애플리케이션 패키징과 배포 </b></p>
<ul>
<li>(pwd 로 현 위치가 /container-orchestration/ 인지 확인)</li>
<li>git clone <a href="https://github.com/event-storming/monolith.git">https://github.com/event-storming/monolith.git</a></li>
<li>cd monolith/</li>
<li>ls</li>
<li>(skip) mvn spring-boot:run #Maven으로 App. 실행</li>
<li>mvn package -B -Dmaven.test.skip=true</li>
<li>(skip) java -jar target/monolith-0.0.1.BUILD-SNAPSHOT.jar #Java로 App. 실행</li>
<li>cat Dockerfile # 도커파일 내용 확인</li>
<li>(도커라이징)
<ul>
<li>docker build -t (Azure container registry명).azurecr.io/monolith:v1 .
<ul>
<li>#주의1 : 명령  맨끝에 &quot; .&quot; 빼먹으면 안됨.   Dockerfile 의 위치인</li>
<li>#주의2 : project id 부분을 자신의 GCP project id 로 변경!!</li>
<li>#주의3 : 현재 연결된 kubernetes 클러스터와 동일한 프로젝트 id 여야만 gcr registry 접근이 가능함</li>
</ul>
</li>
<li>docker images</li>
<li>(skip) docker run (Azure container registry명).azurecr.io/monolith:v1 #Docker로 App. 실행</li>
<li>docker push (azure container registry명).azurecr.io/monolith:v1</li>
</ul>
</li>
<li>kubectl create deploy monolith --image=(azure container registry명).azurecr.io/monolith:v1</li>
<li>kubectl get po -l app=monolith</li>
<li>kubectl expose deploy monolith --type=“LoadBalancer” --port=8080</li>
<li>kubectl get svc -w</li>
<li>자바 애플리케이션 접속
<ul>
<li>http://(Service_Extern-IP):8080</li>
</ul>
</li>
</ul>
</li>
<li>
<p><b>Lab. Circuit Breaker function</b></p>
<ul>
<li>Istio가 활성화된 네임스페이스 생성
<ul>
<li>kubectl create namespace istio-cb-ns</li>
<li>kubectl label namespace istio-cb-ns istio-injection=enabled</li>
</ul>
</li>
<li>[CB 유스케이스] #1. Connection Max &amp; Pending 수에 따른 Circuit Breaker
<ul>
<li>
<p>테스트 어플리케이션 배포 (Deployment, Service)</p>
<pre style="white-space: pre-wrap">
kubectl apply -f - &#60;&#60;EOF
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: httpbin
    namespace: istio-cb-ns
  spec:
    replicas: 1
    selector:
      matchLabels:
        app: httpbin
    template:
      metadata:
        labels:
          app: httpbin
      spec:
        containers:
        - name: httpbin
          image: docker.io/honester/httpbin:latest
          imagePullPolicy: IfNotPresent
          ports:
          - containerPort: 80
  &#45;&#45;&#45;
  apiVersion: v1
  kind: Service
  metadata:
    name: httpbin
    namespace: istio-cb-ns
    labels:
      app: httpbin
  spec:
    selector:
      app: httpbin
    ports:
    - name: http
      port: 8000
      targetPort: 80
EOF
</pre>
</li>
<li>
<p>로드 테스트 툴(siege) 배포</p>
<pre style="white-space: pre-wrap">
kubectl apply -f - &#60;&#60;EOF
  apiVersion: v1
  kind: Pod
  metadata:
    name: siege
    namespace: istio-cb-ns
  spec:
    containers:
    - name: siege
      image: apexacme/siege-nginx
EOF
</pre>
</li>
<li>
<p>siege를 통한 서비스(httpbin) 부하 생성</p>
<ul>
<li>kubectl exec -it siege --container siege -n istio-cb-ns --/bin/bash</li>
<li>siege -c1 -t10S -v <a href="http://httpbin:8000/get">http://httpbin:8000/get</a></li>
<li>siege -c1 -t10S -v http://httpbin.istio-cb-ns:8000/get</li>
<li>siege -c1 -t10S -v <a href="http://httpbin.istio-cb-ns.svc.cluster.local:8000/get">http://httpbin.istio-cb-ns.svc.cluster.local:8000/get</a></li>
<li>서비스 모니터링 (Kiali) : EXTERNAL-IP:20001 (admin/admin)</li>
</ul>
</li>
<li>
<p>DestinationRule 를 생성하여 CB가 발생할 수 있도록 Connection pool 설정</p>
<pre style="white-space: pre-wrap">
kubectl apply -f - &#60;&#60;EOF
  apiVersion: networking.istio.io/v1alpha3
  kind: DestinationRule
  metadata:
    name: dr-httpbin
    namespace: istio-cb-ns
<p>spec:<br />
host: httpbin<br />
trafficPolicy:<br />
connectionPool:<br />
http:<br />
http1MaxPendingRequests: 1<br />
maxRequestsPerConnection: 1<br />
EOF</p>
</pre>
- http1MaxPendingRequests=1 : Queue에서 Connection pool 에 연결을 기다리는 request 수를 1개로 제한
- maxRequestsPerConnection=1 : keep alive 기능 disable
</li>
<li>
<p>siege를 통한 서비스(httpbin) 부하 재생성 및 CB 확인</p>
<ul>
<li>siege -c1 -t10S -v <a href="http://httpbin:8000/get">http://httpbin:8000/get</a>  # 100% Availability</li>
<li>siege -c2 -t10S -v <a href="http://httpbin:8000/get">http://httpbin:8000/get</a>  # 87% availability
<ul>
<li>Envoy will return HTTP 503. It is the responsibility of the application to implement any fallback logic that is needed to handle the HTTP 503 error code from an upstream service. (<a href="https://istio-releases.github.io/v0.1/docs/concepts/traffic-management/handling-failures.html">https://istio-releases.github.io/v0.1/docs/concepts/traffic-management/handling-failures.html</a>)</li>
</ul>
</li>
<li>모니터링 시스템(Kiali) : EXTERNAL-IP:20001 에서 Circuit Breaker 발생 확인 (뱃지)</li>
</ul>
</li>
<li>
<p>Circuit Breaker 제거 후, 동일 로드 생성 후, Availability 100% 확인</p>
<ul>
<li>kubectl delete dr/dr-httpbin -n istio-cb-ns</li>
<li>siege -c2 -t10S -v <a href="http://httpbin:8000/get">http://httpbin:8000/get</a>  # 100% availability</li>
</ul>
</li>
<li>
<p>Clean-up</p>
<ul>
<li>kubectl delete deployment.apps/httpbin service/httpbin -n istio-cb-ns</li>
</ul>
</li>
</ul>
</li>
<li>[CB 유스케이스] #2. Load balancing pool의 인스턴스 상태에 기반한 Circuit Breaker
<ul>
<li>
<p>테스트 어플리케이션 배포 (hello-server-1, hello-server-2 Pods, Service)</p>
</li>
<li>
<p>(hello-server:latest 이미지는 env:RANDOM_ERROR 값의 확률로 랜덤하게 503 에러를 발생하는 로직이 포함)</p>
<pre style="white-space: pre-wrap">
kubectl apply -f - &#60;&#60;EOF
  apiVersion: v1
  kind: Pod
  metadata:
    name: hello-server-1
    namespace: istio-cb-ns
    labels:
      app: hello
  spec:
    containers:
    - name: hello-server-1
      image: docker.io/honester/hello-server:latest
      imagePullPolicy: IfNotPresent
      env:
      - name: VERSION
        value: "v1"
      - name: LOG
        value: "1"
  &#45;&#45;&#45;
  apiVersion: v1
  kind: Pod
  metadata:
    name: hello-server-2
    namespace: istio-cb-ns
    labels:
      app: hello
  spec:
    containers:
    - name: hello-server-2
      image: docker.io/honester/hello-server:latest
      imagePullPolicy: IfNotPresent
      env:
      - name: VERSION
        value: "v2"
      - name: LOG
        value: "1"
      - name: RANDOM_ERROR
        value: "0.2"
  &#45;&#45;&#45;
  apiVersion: v1
  kind: Service
  metadata:
    name: svc-hello
    namespace: istio-cb-ns
    labels:
      app: hello
  spec:
    selector:
      app: hello
    ports:
    - name: http
      protocol: TCP
      port: 8080
EOF
</pre>
</li>
<li>
<p>클라이언트용 Pod 설치</p>
<pre style="white-space: pre-wrap">
kubectl apply -f - &#60;&#60;EOF
  apiVersion: v1
  kind: Pod
  metadata:
    name: httpbin
    namespace: istio-cb-ns
    labels:
      app: httpbin
  spec:
    containers:
    - name: httpbin
      image: docker.io/honester/httpbin:latest
      imagePullPolicy: IfNotPresent
EOF
</pre>
</li>
<li>
<p>클라이언트(httpbin Pod)에서 svc-hello 호출(default, Round-Robin)</p>
<ul>
<li>(hello-server-2의 로그 모니터링)</li>
<li>kubectl logs -f hello-server-2 -c hello-server-2 -n istio-cb-ns</li>
<li>(클라이언트에서 svc-hello 서비스 10번 호출하기)</li>
<li>for i in {1…10}; do kubectl exec -it httpbin -c httpbin -n istio-cb-ns --curl http://svc-hello.istio-cb-ns:8080; sleep 0.1; done</li>
</ul>
</li>
<li>
<p>5XX 오류에 대해 해당 서비스 차단 및 Thread 부하에 따른 DestinationRule 생성</p>
<pre style="white-space: pre-wrap">
kubectl apply -f - &#60;&#60;EOF
  apiVersion: networking.istio.io/v1alpha3
  kind: DestinationRule
  metadata:
    name: dr-hello
    namespace: istio-cb-ns
  spec:
    host: svc-hello
    trafficPolicy:
      connectionPool:
        http:
          http1MaxPendingRequests: 5
          maxRequestsPerConnection: 10
      outlierDetection:
        interval: 1s
        consecutiveErrors: 1
        baseEjectionTime: 3m
        maxEjectionPercent: 100
EOF
<p>설명 : 1초 주기로 이상징후를 체크하며, 1번이라도 실패한 서비스는 3분동안 라우팅 대상에서 제외된다. 또한 모든 대상 서비스 인스턴스가 방출(제외)될 수 있다.&quot;</p>
</pre>
</li>
<li>
<p>클라이언트(httpbin Pod)에서 svc-hello 호출 및 CB 확인</p>
<ul>
<li>(hello-server-2의 로그 모니터링)</li>
<li>kubectl logs -f hello-server-2 -c hello-server-2 -n istio-cb-ns</li>
<li>(클라이언트에서 svc-hello 서비스 10번 호출하기)</li>
<li>for i in {1…10}; do kubectl exec -it httpbin -c httpbin -n istio-cb-ns --curl http://svc-hello.istio-cb-ns:8080; sleep 0.1; done</li>
<li>모니터링 시스템(Kiali) : EXTERNAL-IP:20001 에서 Circuit Breaker 발생 확인 (뱃지)</li>
</ul>
</li>
<li>
<p>배송(delivery) 서비스에 Circuit Breaker 설치</p>
<pre style="white-space: pre-wrap">
kubectl apply -f - &#60;&#60;EOF
  apiVersion: networking.istio.io/v1alpha3
  kind: DestinationRule
  metadata:
    name: dr-delivery
    namespace: cna-shop
  spec:
    host: delivery
    trafficPolicy:
      connectionPool:
        http:
          http1MaxPendingRequests: 5
          maxRequestsPerConnection: 10
      outlierDetection:
        interval: 1s
        consecutiveErrors: 1
        baseEjectionTime: 3m
        maxEjectionPercent: 100
EOF
</pre>
</li>
</ul>
</li>
<li>Clean-up</li>
<li>kubectl delete pod/hello-server-1 pod/hello-server-2 pod/httpbin service/svc-hello dr/dr-hello -n istio-cb-ns</li>
</ul>
</li>
<li>
<p><b>Lab. Istio Egress</b></p>
<ul>
<li>외부 도메인을 호출하는 v3 버전을 배포
<ul>
<li>kubectl apply -f &lt;(istioctl kube-inject -f recommendation/kubernetes/Deployment-v3.yml) -n tutorial</li>
</ul>
</li>
<li>브라우저에서 Customer 서비스(Externl-IP:8080 접속)</li>
<li>v3에서 날짜정보가 추가로 출력됨을 확인</li>
<li>Istio 트래픽을 등록된 것만 허용하도록 변경
<ul>
<li>
<pre style="white-space: pre-wrap">kubectl get configmap istio -n istio-system -o yaml | sed "s/mode: ALLOW_ANY/mode: REGISTRY_ONLY/g" | kubectl replace -n istio-system -f -</pre>
</li>
</ul>
</li>
<li>브라우저에서 Customer 서비스(Externl-IP:8080 접속)
<ul>
<li>v3 은 서비스 오류로 인해 브라우저 확인 불가, Kiali 에서 확인</li>
</ul>
</li>
<li>트래픽을 모두 v3 (weigh 100)로 라우팅하고 에러 화면 확인
<ul>
<li>kubectl create -f istiofiles/destination-rule-recommendation-v1-v2-v3.yml -n tutorial</li>
<li>kubectl create -f istiofiles/virtual-service-recommendation-v3.yml -n tutorial</li>
</ul>
</li>
<li>브라우저에서 Customer 서비스(Externl-IP:8080 접속)
<ul>
<li>화면에 Error Log 출력 : “customer =&gt; Error: 503 - preference =&gt; Error: 500”</li>
</ul>
</li>
<li>외부 도메인을 허용해 주는 ServiceEntry 를 생성하여 정상 접속 허용
<ul>
<li>kubectl create -f istiofiles/service-entry-egress-worldclockapi.yml -n tutorial</li>
<li>브라우저에서 Customer 서비스(Externl-IP:8080 접속) - 정상 출력</li>
</ul>
</li>
<li>(테스트 후, 설정 복구)</li>
<li>
<pre style="white-space: pre-wrap">kubectl get configmap istio -n istio-system -o yaml | sed "s/mode: REGISTRY_ONLY/mode: ALLOW_ANY/g" | kubectl replace -n istio-system -f -</pre>
</li>
</ul>
</li>
</ul>
</details>
</p>
</details>
<hr />
<h3>아마존 AWS</h3>
<details>
<summary>AWS Cloud 기반의 Container Orchestration Lab. Scripts</summary>
<p>
<details>
<summary><b>자주 사용되는 AWS Cloud 명령어</b></summary>
<ul>
<li>
<p><b>Cloud Configuration</b></p>
<ul>
<li>aws configure</li>
</ul>
</li>
<li>
<p><b>AWS 클러스터 생성</b></p>
<ul>
<li>eksctl create cluster --name (Cluster-Name) --version 1.17 --nodegroup-name standard-workers --node-type t3.medium --nodes 3 --nodes-min 1 --nodes-max 3</li>
</ul>
</li>
<li>
<p><b>AWS 클러스터 토큰 가져오기</b></p>
<ul>
<li>aws eks --region (Region-Code) update-kubeconfig --name (Cluster-Name)</li>
</ul>
</li>
<li>
<p><b>AWS 컨테이너 레지스트리에 이미지 리파지토리 생성</b></p>
<ul>
<li>aws ecr create-repository --repository-name (Image-Repository-Name) --image-scanning-configuration scanOnPush=true --region (Region-Code)</li>
</ul>
</li>
<li>
<p><b>AWS 컨테이너 레지스트리 로그인</b></p>
<ul>
<li>aws ecr get-login-password --region (Region-Code) | docker login --username AWS --password-stdin (Account-Id).dkr.ecr.(Region-Code).amazonaws.com</li>
<li>오류(unknown flag: --password-stdin) 발생 시,
<ul>
<li>docker login --username AWS -p $(aws ecr get-login-password --region (Region-Code)) (Account-Id).dkr.ecr.(Region-Code).amazonaws.com/</li>
</ul>
</li>
</ul>
</li>
<li>
<p><b>AWS 레지스트리에 도커 이미지 푸시하기</b></p>
<ul>
<li>aws ecr create-repository --repository-name (IMAGE_NAME) --region ap-northeast-2</li>
<li>docker push <a href="http://283210891307.dkr.ecr.ap-northeast-2.amazonaws.com/(IMAGE_NAME):latest">283210891307.dkr.ecr.ap-northeast-2.amazonaws.com/(IMAGE_NAME):latest</a></li>
</ul>
</li>
<li>
<p><b>AWS 클러스터 삭제</b></p>
<ul>
<li>eksctl delete cluster --name (PROD_CLUSTER)</li>
</ul>
</li>
<li>
<p><b>AWS EKS 모니터링</b></p>
<ul>
<li>Metric-Server 설치
<ul>
<li>kubectl apply -f <a href="https://github.com/kubernetes-sigs/metrics-server/releases/download/v0.5.0/components.yaml">https://github.com/kubernetes-sigs/metrics-server/releases/download/v0.5.0/components.yaml</a></li>
</ul>
</li>
<li>Kubernetes DashBoard 설치
<ul>
<li>kubectl apply -f <a href="https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-beta8/aio/deploy/recommended.yaml">https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-beta8/aio/deploy/recommended.yaml</a></li>
</ul>
</li>
<li>eks-admin 서비스 계정 및 클러스터 롤 바인딩 생성<pre style="white-space: pre-wrap">
cat &#60;&#60;EOF | kubectl apply -f -
  apiVersion: v1
  kind: ServiceAccount
  metadata:
    name: eks-admin
    namespace: kube-system
  &#45;&#45;&#45;
  apiVersion: rbac.authorization.k8s.io/v1beta1
  kind: ClusterRoleBinding
  metadata:
    name: eks-admin
  roleRef:
    apiGroup: rbac.authorization.k8s.io
    kind: ClusterRole
    name: cluster-admin
  subjects:
  - kind: ServiceAccount
    name: eks-admin
    namespace: kube-system
EOF
</pre>
</li>
<li>인증 토큰 조회
<ul>
<li>
<pre style="white-space: pre-wrap">kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep eks-admin | awk "{print $1}")</pre>
</li>
</ul>
</li>
<li>Proxy 설정 및 DashBoard 연결
<ul>
<li>kubectl proxy</li>
<li><a href="http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/#!/login">http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/#!/login</a></li>
<li>복사한 토큰 정보로 로그인</li>
</ul>
</li>
</ul>
</li>
</ul>
</details>
<h3>Docker</h3>
<details>
<summary><b>Setup</b></summary>
<ul>
<li>
<p><b>관리자 권한으로 PowerShell 실행</b></p>
<ul>
<li>Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux</li>
</ul>
</li>
<li>
<p><b>리눅스설치 및 실행</b></p>
<ul>
<li>(설치전 확인 사항)
<ul>
<li>Windows 기능 켜기/끄기에서 “Linux용 Windows 하위시스템 활성화” 확인</li>
<li>개발자 기능사용에서 “개발자 모드” 활성화 확인</li>
</ul>
</li>
<li>Ubuntu의 Archive Repository Server를 (빠른 패키지 설치를 위해) 국내로 설정
<ul>
<li>sudo vi /etc/apt/sources.list</li>
<li>:%s/archive.ubuntu.com/ftp.daumkakao.com/g</li>
<li>:wq!</li>
<li>sudo apt-get update</li>
</ul>
</li>
</ul>
</li>
<li>
<p><b>Linux에 JDK 설치</b></p>
<ul>
<li>
<p>(설치 명령)</p>
</li>
<li>
<p>sudo apt-get update</p>
</li>
<li>
<p>sudo apt install default-jdk</p>
</li>
<li>
<p>(bash에 환경변수 추가)</p>
</li>
<li>
<p>cd ~</p>
</li>
<li>
<p>nano .bashrc</p>
</li>
<li>
<p>(맨아래로 이동)</p>
</li>
<li>
<p>(JAVA_HOME 설정 및 실행 Path 추가)</p>
<pre style="white-space: pre-wrap">
export JAVA_HOME="/usr/lib/jvm/java-11-openjdk-amd64"
export PATH=$PATH:$JAVA_HOME/bin:.
</pre>
</li>
<li>
<p>(수정사항 반영)</p>
<ul>
<li>ctrl + x, y 입력, 종료</li>
<li>source ~/.bashrc</li>
</ul>
</li>
<li>
<p>(설치 확인)</p>
</li>
<li>
<p>echo $JAVA_HOME</p>
</li>
<li>
<p>java -version</p>
</li>
</ul>
</li>
<li>
<p><b>Windows에 도커 데몬 설치</b></p>
<ul>
<li><a href="https://www.docker.com/products/docker-desktop">https://www.docker.com/products/docker-desktop</a></li>
</ul>
</li>
<li>
<p><b>도커허브 계정생성</b></p>
<ul>
<li><a href="http://hub.docker.com">http://hub.docker.com</a> 접속 후, Sign Up (회원가입)</li>
</ul>
</li>
<li>
<p><b>리눅스에 도커 Client 설치</b></p>
<ul>
<li>sudo apt-get update</li>
<li>비밀번호 입력창에 skadmin1234</li>
<li>sudo apt install apt-transport-https ca-certificates curl software-properties-common</li>
<li>curl -fsSL <a href="https://download.docker.com/linux/ubuntu/gpg">https://download.docker.com/linux/ubuntu/gpg</a> | sudo apt-key add</li>
<li>sudo add-apt-repository “deb [arch=amd64] <a href="https://download.docker.com/linux/ubuntu">https://download.docker.com/linux/ubuntu</a> bionic stable”</li>
<li>sudo apt update</li>
<li>sudo apt install docker-ce</li>
<li>#리눅스 설치시 생성한 사용자 명 입력</li>
<li>sudo usermod -aG docker skccadmin</li>
</ul>
</li>
<li>
<p><b>도커 데몬과 도커 Client 연결 </b></p>
<ul>
<li>cd</li>
<li>nano .bashrc</li>
<li>맨아래 줄에 아래 환경변수 추가
<ul>
<li>방향키로 맨 아래까지 내린 다음, 새로운 행에 아래 내용 입력</li>
<li>export DOCKER_HOST=tcp://0.0.0.0:2375</li>
<li>저장 &amp; 종료 : Ctrl + x, 입력 후, y 입력  후 엔터</li>
</ul>
</li>
<li>source ~/.bashrc</li>
<li>연결 확인
<ul>
<li>docker images</li>
<li>docker run --name nginx -d -p 80:80 nginx</li>
<li>docker images</li>
</ul>
</li>
</ul>
</li>
</ul>
</details>
<details>
<summary><b>Docker Hands-on</b></summary>   </b>
<ul>
<li>
<p><b>Lab. image</b></p>
<ul>
<li>
<p>이미지 Pull</p>
<ul>
<li>docker pull hello-world</li>
<li>docker images</li>
<li>docker pull nginx</li>
<li>docker pull nginx:latest</li>
<li>docker pull <a href="http://docker.io/library/nginx:latest">docker.io/library/nginx:latest</a></li>
<li>docker pull nginx:1.16.1</li>
<li>docker images</li>
</ul>
</li>
<li>
<p>도커허브 (Docker Hub)</p>
<ul>
<li><a href="http://hub.docker.com">http://hub.docker.com</a> # 접속 후, nginx 검색</li>
</ul>
</li>
<li>
<p>이미지 Tagging</p>
<ul>
<li>docker image tag nginx my-nginx # Create 태그</li>
</ul>
</li>
<li>
<p>이미지 삭제</p>
<ul>
<li>docker image rm my-nginx</li>
<li>docker image rm hello-world</li>
<li>docker image rm $(docker images -q) # 한번에 모든 도커 이미지 지우기</li>
</ul>
</li>
</ul>
</li>
<li>
<p><b>Lab. container</b></p>
<ul>
<li>컨테이너 생성
<ul>
<li>docker run hello-world # 컨테이너 만들기</li>
<li>docker run --name hello hello-world # 이름 지정, 미지정시 임의의 이름으로 생성</li>
<li>docker run --name my-nginx -d -p 80:80 nginx</li>
<li>docker ps</li>
</ul>
</li>
<li>컨테이너 시작/종료
<ul>
<li>docker stop my-nginx</li>
<li>docker start my-nginx</li>
</ul>
</li>
<li>컨테이너 포트 노출
<ul>
<li><a href="http://localhost">http://localhost</a> 에서 nginx index.html 확인</li>
<li>docker container rm my-nginx</li>
<li>docker run --name my-nginx -d -p 8080:80 nginx</li>
<li><a href="http://localhost:8080">http://localhost:8080</a> 에서 nginx index.html 확인</li>
</ul>
</li>
<li>컨테이너 접근
<ul>
<li>docker exec my-nginx cat /usr/share/nginx/html/index.html #실행 중 컨테이너 접근</li>
<li>docker exec -i -t  my-nginx /bin/bash
<ul>
<li>apt-get update</li>
<li>apt-get install curl</li>
<li>curl localhost</li>
<li>exit</li>
</ul>
</li>
</ul>
</li>
<li>컨테이너 삭제
<ul>
<li>docker container rm my-nginx # 실행 중 컨테이너  삭제 시, 오류</li>
<li>docker container rm $(docker ps -a -q) # 한번에 모든 컨테이너 지우기</li>
</ul>
</li>
</ul>
</li>
<li>
<p><b>Lab. Docker Build &amp; Push</b></p>
<ul>
<li>Dockerfile로부터 이미지 생성
<ul>
<li>Dockerfile &amp; 리소스 생성
<ul>
<li>mkdir Dockerfile</li>
<li>cd Dockerfile</li>
<li>nano index.html<pre style="white-space: pre-wrap">"Hi~ My name is Park Yong Joo.."</pre>
<ul>
<li>저장 및 종료 (Ctrl + X, y 입력 후 엔터)</li>
<li>nano Dockerfile<pre style="white-space: pre-wrap">
FROM nginx
COPY index.html /usr/share/nginx/html/
</pre>
</li>
</ul>
</li>
<li>저장 및 종료 (Ctrl + x, Y 입력 후 엔터)</li>
</ul>
</li>
<li>도커라이징 &amp; Push
<ul>
<li>docker build -t Docker-ID/my-nginx:v1 .</li>
<li>docker images</li>
<li>docker push Docker-ID/my-nginx:v1<br />
&quot;denied: 권한오류 생성 시, docker login 명령으로 Docker Hub에 로그인해 준다.&quot;</li>
</ul>
</li>
<li><a href="http://hub.docker.com">http://hub.docker.com</a> 에서 이미지 확인</li>
<li>Docker Hub 이미지로부터 컨테이너 실행
<ul>
<li>docker run --name new-nginx -d -p 80:80 Docker-ID/my-nginx:v1</li>
</ul>
</li>
<li>Browser에서 실행 애플리케이션 확인
<ul>
<li><a href="http://localhost:8080">http://localhost:8080</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><b>Clear</b></p>
<ul>
<li>docker container rm $(docker ps -a -q)
<ul>
<li>container 삭제 전, 실행 중인 컨테이너를 정지시켜 준다.</li>
<li>docker container stop new-nginx</li>
</ul>
</li>
<li>docker image rm -f $(docker images -q)</li>
</ul>
</li>
</ul>
</details>
<h3>Kubernetes</h3>
<details>
<summary><b>Cloud Client Setup</b></summary>
<ul>
<li>
<p><b>Kubectl 설치 (ubuntu 18.04)</b></p>
<ul>
<li>sudo apt-get update &amp;&amp; sudo apt-get install -y apt-transport-https</li>
<li>curl -s <a href="https://packages.cloud.google.com/apt/doc/apt-key.gpg">https://packages.cloud.google.com/apt/doc/apt-key.gpg</a> | sudo apt-key add -</li>
<li>echo “deb <a href="https://apt.kubernetes.io/">https://apt.kubernetes.io/</a> kubernetes-xenial main” | sudo tee -a /etc/apt/sources.list.d/kubernetes.list</li>
<li>sudo apt-get update</li>
<li>sudo apt-get install -y kubectl</li>
</ul>
</li>
<li>
<p><b>AWS-Cli v2 설치</b></p>
<ul>
<li>curl “<a href="https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip">https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip</a>” -o “awscliv2.zip”</li>
<li>unzip awscliv2.zip</li>
<li>(unzip이 없을 경우, 설치)
<ul>
<li>sudo apt-get install unzip</li>
</ul>
</li>
<li>sudo ./aws/install</li>
</ul>
</li>
<li>
<p><b>AWS Configure</b></p>
<ul>
<li>(AWS 관리콘솔)</li>
<li>
<ol>
<li>부여받은 교육 계정으로  AWS 콘솔 접속</li>
</ol>
</li>
<li>
<ol start="2">
<li>IAM 서비스 접속</li>
</ol>
</li>
<li>
<ol start="3">
<li>왼쪽 메뉴에서 “엑세스 관리” &gt; “사용자” 클릭</li>
</ol>
</li>
<li>
<ol start="4">
<li>나의 계정정보 클릭</li>
</ol>
</li>
<li>
<ol start="5">
<li>메인화면에서 “보안자격증명” 클릭</li>
</ol>
</li>
<li>
<ol start="6">
<li>“액세스 키 만들기” 클릭</li>
</ol>
</li>
<li>
<ol start="7">
<li>Access Key ID와 Secret Access key를 복사</li>
</ol>
</li>
<li>(클라이언트 Tool)</li>
<li>aws configure 입력</li>
<li>관리콘솔에 복사한 Access Key ID와 Secret Access key 입력</li>
<li>region 정보에 ap-northeast-2 입력</li>
<li>default output format에 json 입력</li>
</ul>
</li>
<li>
<p><b>EKS Client (eksctl) 설치</b></p>
<ul>
<li>curl --location “<a href="https://github.com/weaveworks/eksctl/releases/download/latest_release/eksctl_$">https://github.com/weaveworks/eksctl/releases/download/latest_release/eksctl_$</a>(uname -s)_amd64.tar.gz” | tar xz -C /tmp</li>
<li>sudo mv /tmp/eksctl /usr/local/bin</li>
</ul>
</li>
<li>
<p><b>Amazon EKS 생성</b></p>
<ul>
<li>eksctl create cluster --name user15-sk-Cluster --version 1.15 --nodegroup-name standard-workers --node-type t3.medium --nodes 2 --nodes-min 1 --nodes-max 3</li>
</ul>
</li>
<li>
<p><b>Local에 EKS 클러스터 접속정보 설정</b></p>
<ul>
<li>aws eks --region eu-west-1 update-kubeconfig --name admin00-Cluster</li>
<li>kubectl config current-context</li>
<li>kubectl get all</li>
</ul>
</li>
<li>
<p><b>Local에 ECR(Elastic Container Registry) 인증 및 토큰 설정</b></p>
<ul>
<li>aws ecr get-login-password --region ap-northeast-2 | docker login --username AWS --password-stdin (Account-ID).dkr.ecr.ap-northeast-2.amazonaws.com</li>
<li>오류(unknown flag: --password-stdin) 발생 시,
<ul>
<li>docker login --username AWS -p $(aws ecr get-login-password --region ca-central-1) <a href="http://052937454741.dkr.ecr.ca-central-1.amazonaws.com/">052937454741.dkr.ecr.ca-central-1.amazonaws.com/</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</details>
<details>
<summary><b>Kubernetes Hands-on</b></summary>
<ul>
<li>
<p><b>Lab에 필요한 리소스 내려받기</b></p>
<ul>
<li>git clone <a href="https://github.com/acmexii/mall.git">https://github.com/acmexii/mall.git</a></li>
<li>git clone <a href="https://github.com/event-storming/container-orchestration.git">https://github.com/event-storming/container-orchestration.git</a></li>
<li>cd container-orchestration</li>
<li>cd yaml_aws</li>
</ul>
</li>
<li>
<p><b>Lab. K8s Sample App 생성</b></p>
<ul>
<li>어플리케이션 생성/ 확인
<ul>
<li>Docker hub에 올린 이미지를 통한 컨테이너 생성<br />
kubectl create deploy my-nginx --image=apexacme/my-nginx:v1&quot;</li>
<li>클러스터 외부에 노출하기<br />
kubectl expose deploy my-nginx --type=LoadBalancer --port=80&quot;</li>
</ul>
</li>
<li>서비스 확인하기
<ul>
<li>kubectl get svc의 EXTERNAL-IP 복사</li>
<li>Browser에서 EXTERNAL-IP:80 접속</li>
</ul>
</li>
</ul>
</li>
<li>
<p><b>Lab. Pod &amp; 기본명령</b></p>
<ul>
<li>kubectl get nodes
<ul>
<li>쿠버네티스에 제대로 접속했는지 확인</li>
<li>현 클러스터의 워크노드를 리스트업</li>
<li>접속 결과 안나오는 경우
<ul>
<li>kubectl config current-context 명령으로 Cluster 접속 확인</li>
</ul>
</li>
</ul>
</li>
<li>객체의 검색
<ul>
<li>kubectl get [object type]</li>
<li>kubectl get pods   # pods = pod = po</li>
<li>kubectl get deployments   # deploy</li>
<li>kubectl get services    # svc</li>
<li>kubectl get replicaset    # rs</li>
</ul>
</li>
<li>객체의 모니터링
<ul>
<li>watch kubectl get all</li>
<li>kubectl get pod -w</li>
<li>watch kubectl get pod</li>
</ul>
</li>
<li>객체의 유형
<ul>
<li>Service
<ul>
<li>types
<ul>
<li>LoadBalancer
<ul>
<li>클라우드 제공자에 의해 제공된 Loadbalancer 로 노출</li>
<li>front-end 혹은 ingress (api gateway)</li>
</ul>
</li>
<li>ClusterIP(default) / NodePort
<ul>
<li>클러스터 내부 IP</li>
<li>내부 마이크로 서비스</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Deployment
<ul>
<li>ReplicaSet (하나이상 생성)
<ul>
<li>Pod (하나이상 생성)
<ul>
<li>Container (docker ) 하나이상.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Pod</li>
<li>ReplicaSet</li>
<li>Ingress</li>
<li>Secret</li>
<li>ConfigMap</li>
<li>ServiceAccount = sa</li>
<li>statefulset</li>
<li>daemonset</li>
</ul>
</li>
<li>설정파일(YAML)을 통한 Pod 배포 (직접 타이핑)
<ul>
<li>nano declarative-pod.yaml<pre style="white-space: pre-wrap">
apiVersion: v1
kind: Pod
metadata:
  name: declarative-pod
  labels:
    env: test
spec:
  containers:
  - name: memory-demo-ctr
    image: nginx
</pre>
</li>
<li>저장 및 종료 (ctrl + X, Y, 엔터)</li>
<li>kubectl create -f declarative-pod.yaml</li>
<li>kubectl get pods</li>
</ul>
</li>
<li>원하는 Node 타입에 Pod 생성
<ul>
<li>#pwd 로 현 위치가 /container-orchestration/yaml_aws/pod 인지 확인</li>
<li>kubectl create -f pod-with-nodeselector.yaml</li>
<li>kubectl get po -o wide
<ul>
<li>Pod가 찾는 노드가 없어 pending 상태</li>
</ul>
</li>
<li>노드에 라벨 추가
<ul>
<li>kubectl label nodes <your-node-name> disktype=ssd</li>
<li>kubectl get nodes --show-labels | grep ssd</li>
</ul>
</li>
<li>kubectl get po -o wide</li>
</ul>
</li>
<li>Pod 생성 전 초기화
<ul>
<li>kubectl create -f pod-initialize.yaml</li>
<li>kubectl get po</li>
<li>#생성된 Pod 내로 접근</li>
<li>kubectl exec -it init-demo --/bin/bash</li>
<li>cd /usr/share/nginx/html</li>
<li>ls</li>
</ul>
</li>
<li>생성된 Pod, 및 오브젝트 삭제
<ul>
<li>kubectl delete pod [pod명]</li>
<li>kubectl delete service,deploy --all</li>
</ul>
</li>
</ul>
</li>
<li>
<p><b>Lab. Label </b></p>
<ul>
<li>2개의 Pod 생성</li>
<li>(1. pod 폴더로 이동하여, 아래 명령어 실행)</li>
<li>kubectl create -f pod-with-nodeselector.yaml</li>
<li>(2. 아래 nginx 컨테이너 생성)</li>
<li>kubectl run nginx2 --image=nginx</li>
<li>kubectl get pods -l run=nginx2</li>
<li>kubectl get pods --selector run=nginx2</li>
<li>
<pre style="white-space: pre-wrap">kubectl get pods --selector "run in (nginx2, test)"</pre>
</li>
</ul>
</li>
<li>
<p><b>Lab. Rollout &amp; RollBack</b></p>
<ul>
<li>(pwd 로 현 위치가 /container-orchestration/yaml_aws/ 인지 확인)</li>
<li>kubectl create -f nginx.yaml</li>
<li>(아래 명령으로 배포 주석 추가, Rollback시 필요)</li>
<li>
<pre style="white-space: pre-wrap">kubectl annotate deploy nginx-deployment kubernetes.io/change-cause="v1 is nginx:1.7.9"</pre>
</li>
<li>Set image 명령을 통한 이미지 Rollout  및 확인</li>
<li>kubectl set image deploy nginx-deployment nginx=nginx:1.9.1</li>
<li>kubectl rollout history deploy nginx-deployment</li>
<li>(배포주석 달기)</li>
<li>
<pre style="white-space: pre-wrap">kubectl annotate deploy nginx-deployment kubernetes.io/change-cause="v2 is revisioned nginx:1.9.1"</pre>
</li>
<li>kubectl describe po &lt;해당 deployment 의 pod 중 하나의 이름&gt;    # 내용의 image 부분이 1.9.1 인지 확인</li>
<li>(무정지 재배포 히스토리 확인)</li>
<li>kubectl rollout history deploy nginx-deployment</li>
<li>(다음과 같이 출력됨을 확인)<br />
“REVISION  CHANGE-CAUSE<br />
1         v1 is nginx:1.7.9<br />
2         v2 is nginx:1.9.1”</li>
<li>(롤백하기)</li>
<li>kubectl rollout undo deploy nginx-deployment</li>
<li>kubectl rollout undo deploy nginx-deployment --to-revision 1</li>
</ul>
</li>
<li>
<p><b>Lab. ReplicaSet</b></p>
<ul>
<li>pwd 로 현 위치가 /container-orchestration/yaml_aws/replicaset 인지 확인</li>
<li>kubectl create -f replicaset.yaml</li>
<li>kubectl get all</li>
<li>#replica 개수 조정
<ul>
<li>kubectl scale replicaset/frontend --replicas=5</li>
<li>kubectl get po</li>
</ul>
</li>
</ul>
</li>
<li>
<p><b>Lab. Deployment &amp; 기본명령 </b></p>
<ul>
<li>기본 nginx 서버의 배포</li>
<li>kubectl create deploy nginx --image=nginx</li>
<li>kubectl get deploy nginx</li>
<li>kubectl get replicaset -l app=nginx</li>
<li>kubectl get po -l app=nginx  # “-l” 옵션은 label의 key/value 로 객체를 필터링</li>
<li>kubectl get pods --selector app=nginx</li>
<li>
<pre style="white-space: pre-wrap">kubectl get pods --selector "app in (nginx, test)"</pre>
</li>
<li>kubectl describe po (검색한 pod name)</li>
<li>(pod 제거)</li>
<li>kubectl delete po --all   #</li>
<li>(pod 를 제거해도 재생됨을 확인)</li>
<li>kubectl get po</li>
<li>(scale out)</li>
<li>kubectl scale deploy nginx --replicas=3</li>
<li>kubectl get po   # pod 개수가 3개로 늘어남을 확인</li>
<li>kubectl delete po --all   # pod 를 모두 지움</li>
<li>kubectl get po   # pod 를 모두 지워도 결국 3개로 복원됨을 확인</li>
<li>( 제거하기 위해서는 deployment 를 제거해야만 함)</li>
<li>kubectl delete deploy nginx</li>
</ul>
</li>
<li>
<p><b>Auto Scale-Out </b></p>
<ul>
<li>
<p>pwd 로 현 위치가 /container-orchestration/yaml_aws/ 인지 확인</p>
</li>
<li>
<p>(모든 객체 지우기)</p>
</li>
<li>
<p>kubectl delete deploy,service --all</p>
</li>
<li>
<p>(대상 서비스 배포 및 모니터링)</p>
</li>
<li>
<p>kubectl apply -f <a href="https://k8s.io/examples/application/php-apache.yaml">https://k8s.io/examples/application/php-apache.yaml</a></p>
<ul>
<li>NOTE : 서비스가 Auto Scaling되기 위해서는 컨테이너 Spec에 Resources : 설정이 있어야 함<br />
&quot; resources:<br />
limits:<br />
cpu: 500m<br />
requests:<br />
cpu: 200m&quot;</li>
</ul>
</li>
<li>
<p>(오토 스케일링 설정, hpa: HorizontalPodAutoscaler )</p>
<ul>
<li>kubectl autoscale deployment php-apache --cpu-percent=50 --min=1 --max=10<br />
cpu-percent=50 : Pod 들의 요청 대비 평균 CPU 사용율 (여기서는  요청이 200 milli-cores이므로, 모든 Pod의 평균 CPU 사용율이 100 milli-cores(50%)를 넘게되면 HPA 발생)&quot;</li>
<li>kubectl get hpa php-apache -o yaml</li>
</ul>
</li>
<li>
<p>로드 제너레이터(siege)가 설치된 컨테이너 생성</p>
<ul>
<li>cat siege.yaml</li>
<li>kubectl create -f siege.yaml</li>
<li>kubectl exec -it siege --/bin/bash</li>
</ul>
</li>
<li>
<p>로드 생성</p>
<ul>
<li>siege -c30 -t30S -v http://php-apache</li>
</ul>
</li>
<li>
<p>(오토 스케일링이 되지 않을 때 :  kubectl get hpa의 TARGETS 부분에 cpu 사용률이 <unknown>으로 출력될 때)</p>
<ul>
<li>metrics-server가 제대로 실행중인지 kubectl top pods 명령으로 포드 cpu 사용률이 모니터링 되는지 확인</li>
<li>디플로이먼트의 컨테이너 옵션에 cpu request 옵션이 제대로 걸려 있는지 확인</li>
<li>cpu request옵션이 없으면 hpa가 cpu사용량에 필요한 계산을 할 수 없음</li>
</ul>
</li>
</ul>
</li>
<li>
<p><b>Lab. Service</b></p>
<ul>
<li>Basic YAML  <pre style="white-space: pre-wrap">
  apiVersion: v1
  kind: Service
  metadata:
    name: my-service
  spec:
    selector:
      app: MyApp
    ports:
      - protocol: TCP
        port: 80
        targetPort: 8080
  </pre>
</li>
<li>kubectl delete service,deploy --all  # 기존 이력 삭제</li>
<li>(다시 생성)</li>
<li>kubectl create deploy nginx --image=nginx</li>
<li>(서비스로 노출)</li>
<li>kubectl expose deploy nginx --type=“LoadBalancer” --port=80</li>
<li>(웹 브라우저를 열고 생성된 external ip 로 접속, Nginx welcome 메시지 확인)</li>
<li>kubectl exec -it (pod name) --/bin/bash   # 생성된 nginx 서버 linux 의 shell 에 접근</li>
</ul>
</li>
<li>
<p><b>Lab. Volume</b></p>
<ul>
<li>(pwd 로 현 위치가 /container-orchestration/yaml_aws/volume 인지 확인)</li>
<li>(emptyDir 마운트)</li>
<li>kubectl create -f volume-emptydir.yaml</li>
<li>(GitRepository를 볼륨으로 마운트)</li>
<li>kubectl create -f volume-gitrepo.yaml</li>
<li>(EFS - Elastic File System 생성하기)
<ul>
<li>관리콘솔에서 EFS 생성</li>
<li>EFS Service Account 생성 : efs-sa.yaml 실행</li>
<li>EFS Provisioner 배포 :
<ul>
<li>관리콘솔에서 생성한 efs ID와 DNS 정보로 수정</li>
<li>nano efs-provisioner-deploy.yaml</li>
<li>efs-provisioner-deploy.yaml 실행</li>
</ul>
</li>
<li>SA 권한 설정 :  efs-rbac.yaml 실행</li>
<li>StorageClass 생성 :  efs-storageclass.yaml 실행</li>
</ul>
</li>
<li>(PersistentVolumeClaim 생성)</li>
<li>kubectl create -f volume-pvc.yaml</li>
<li>kubectl get pvc</li>
<li>kubectl describe pvc aws-efs</li>
<li>(생성된 PersistentVolueClaim으로 Pod 생성하기)</li>
<li>kubectl create -f pod-with-pvc.yaml</li>
<li>kubectl describe pod mypod</li>
<li>(포드 접속)</li>
<li>kubectl exec -it mypod --/bin/bash</li>
<li>(마운트 및 사이즈 확인)</li>
<li>df -k</li>
</ul>
</li>
<li>
<p><b>Lab. ConfigMap</b></p>
<ul>
<li>(pwd 로 현 위치가 /container-orchestration/yaml_aws/configmap/ 인지 확인)</li>
<li>(컨피그 맵 생성)</li>
<li>kubectl create configmap hello-cm --from-literal=language=java</li>
<li>kubectl get cm</li>
<li>kubectl get cm hello-cm -o yaml</li>
<li>(도커라이징 &amp; ECR Push)
<ul>
<li>docker build -t <a href="http://052937454741.dkr.ecr.ap-northeast-2.amazonaws.com/user01-cm-sandbox:v1">052937454741.dkr.ecr.ap-northeast-2.amazonaws.com/user01-cm-sandbox:v1</a> .</li>
<li>aws ecr create-repository --repository-name user22-cm-sandbox --region ap-northeast-2</li>
<li>docker push <a href="http://052937454741.dkr.ecr.ap-northeast-2.amazonaws.com/user01-cm-sandbox:v1">052937454741.dkr.ecr.ap-northeast-2.amazonaws.com/user01-cm-sandbox:v1</a></li>
</ul>
</li>
<li>(인증오류 발생 시, ECR 로그인)
<ul>
<li>aws ecr get-login-password --region ap-northeast-2 | docker login --username AWS --password-stdin <a href="http://052937454741.dkr.ecr.ap-northeast-2.amazonaws.com/">052937454741.dkr.ecr.ap-northeast-2.amazonaws.com/</a></li>
<li>오류(unknown flag: --password-stdin) 발생 시,
<ul>
<li>docker login --username AWS -p $(aws ecr get-login-password --region (Region-Code)) (Account-Id).dkr.ecr.(Region-Code).amazonaws.com/</li>
</ul>
</li>
</ul>
</li>
<li>클라우드에서 배포 이미지 확인</li>
<li>nano cm-deployment.yaml 파일 편집(나의 ECR Registry 정보로 수정)</li>
<li>(배포 및 서비스 생성)
<ul>
<li>kubectl create -f cm-deployment.yaml</li>
<li>kubectl create -f cm-service.yaml</li>
</ul>
</li>
<li>(서비스 확인)
<ul>
<li>Service의 External-IP 접속</li>
</ul>
</li>
</ul>
</li>
<li>
<p><b>Lab. Secret</b></p>
<ul>
<li>(pwd 로 현 위치가 /container-orchestration/yaml_aws/secret/ 인지 확인)</li>
<li>kubectl create secret generic my-password --from-literal=password=mysqlpassword</li>
<li>(Pod에서 Secret 파일 마운트 사용하기 내용을 참고하여 배포 및 서비스 확인해 보기)</li>
</ul>
</li>
<li>
<p><b>Lab. Liveness &amp; Readiness Probe</b></p>
<ul>
<li>(pwd 로 현 위치가 /container-orchestration/yaml_aws/liveness/ 인지 확인)</li>
<li>(Liveness Command Probe 실습)
<ul>
<li>kubectl create -f exec-liveness.yaml</li>
<li>(컨테이너가 Running 상태로 보이나, Liveness Probe 실패로 계속 재시작)</li>
<li>(kubectl describe로 실패 메시지 확인)</li>
<li>kubectl describe po liveness-exec</li>
</ul>
</li>
<li>(Liveness HTTP Probe 실습)
<ul>
<li>kubectl create -f http-liveness.yaml</li>
<li>(kubectl describe로 실패 메시지 확인)</li>
<li>kubectl describe po liveness-http</li>
</ul>
</li>
<li>(Liveness 와 readiness probe 동시 적용 실습)
<ul>
<li>kubectl create -f tcp-liveness-readiness.yaml</li>
<li>(8080포트에 대해 정상적으로 Liveness 와 readiness Probe를 통과해 서비스가 실행됨)</li>
<li>kubectl describe po goproxy</li>
</ul>
</li>
</ul>
</li>
</ul>
</details>
<details>
<summary><b>Kubernetes Advanced Hands-on</b></summary>
<ul>
<li><b>Lab. Ingress</b>
<ul>
<li>Helm 명령으로 설치 여부 확인</li>
<li>Helm 이 설치되어 있지 않은 경우, Helm(패키지 인스톨러) 설치
<ul>
<li>Helm 3.x 설치(권장)
<ul>
<li>curl <a href="https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3">https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3</a> &gt; get_helm.sh</li>
<li>chmod 700 get_helm.sh</li>
<li>./get_helm.sh</li>
</ul>
</li>
<li>Helm 2.x 설치
<ul>
<li>curl <a href="https://raw.githubusercontent.com/kubernetes/helm/master/scripts/get">https://raw.githubusercontent.com/kubernetes/helm/master/scripts/get</a> | bash</li>
<li>(설치 중, sudo를 위한 비밀번호 입력)</li>
<li>kubectl --namespace kube-system create sa tiller</li>
<li>kubectl create clusterrolebinding tiller --clusterrole cluster-admin --serviceaccount=kube-system:tiller</li>
<li>helm init --service-account tiller</li>
</ul>
</li>
</ul>
</li>
<li>Helm으로 Ingress Controller 설치
<ul>
<li>helm repo add stable <a href="https://charts.helm.sh/stable">https://charts.helm.sh/stable</a></li>
<li>helm repo add ingress-nginx <a href="https://kubernetes.github.io/ingress-nginx">https://kubernetes.github.io/ingress-nginx</a></li>
<li>helm repo update</li>
<li>kubectl create namespace ingress-basic</li>
<li>helm version 확인</li>
<li>(helm version 2.x 일때)
<ul>
<li>helm install --name nginx-ingress stable/nginx-ingress  --namespace=ingress-basic</li>
</ul>
</li>
<li>(helm version 3.x 일때)
<ul>
<li>helm install nginx-ingress ingress-nginx/ingress-nginx --namespace=ingress-basic</li>
</ul>
</li>
<li>(설치확인)
<ul>
<li>kubectl get all --namespace=ingress-basic</li>
<li>(Ingress Controller의 EXTERNAL-IP가 API Gateway 엔드포인트: 메모 必)</li>
</ul>
</li>
<li>Ingress 대상 서비스(BLUE, GREEN) 생성
<ul>
<li>(pwd 로 현 위치가 /container-orchestration/yaml_aws/ingress/blue-svc/ 인지 확인)
<ul>
<li>(도커라이징 &amp; 이미지 Push)</li>
<li>docker build -t <a href="http://052937454741.dkr.ecr.ap-northeast-2.amazonaws.com/user30-nginx-blue:latest">052937454741.dkr.ecr.ap-northeast-2.amazonaws.com/user30-nginx-blue:latest</a>  .</li>
<li>aws ecr create-repository --repository-name user30-nginx-blue --region ap-northeast-2</li>
<li>docker push <a href="http://052937454741.dkr.ecr.ap-northeast-2.amazonaws.com/user30-nginx-blue:latest">052937454741.dkr.ecr.ap-northeast-2.amazonaws.com/user30-nginx-blue:latest</a></li>
<li>(배포 전 yaml을 열어 image URL을 나의 ACR이름으로 수정)</li>
<li>nano nginx-blue-deployment.yaml</li>
<li>(저장 ctrl + X)</li>
<li>(배포 및 서비스 생성)</li>
<li>kubectl create -f nginx-blue-deployment.yaml</li>
</ul>
</li>
<li>(pwd 로 현 위치가 /container-orchestration/yaml_aws/ingress/green-svc/ 인지 확인)
<ul>
<li>(도커라이징 &amp; 이미지 Push)</li>
<li>docker build -t (283210891307).dkr.ecr.ap-northeast-2.amazonaws.com/nginx-green:latest  .</li>
<li>aws ecr create-repository --repository-name nginx-green --region ap-northeast-2</li>
<li>docker push (283210891307).dkr.ecr.ap-northeast-2.amazonaws.com/nginx-green:latest</li>
<li>(배포 전 yaml을 열어 image URL을 나의 ACR이름으로 수정)</li>
<li>nano nginx-green-deployment.yaml</li>
<li>(저장 ctrl + X)</li>
<li>(배포 및 서비스 생성)</li>
<li>kubectl create -f nginx-green-deployment.yaml</li>
</ul>
</li>
<li>(서비스 생성 확인)
<ul>
<li>kubectl get deploy,service -n ingress-basic</li>
</ul>
</li>
</ul>
</li>
<li>Ingress Routing Rule 생성
<ul>
<li>(pwd 로 현 위치가 /container-orchestration/yaml_aws/ingress/ 인지 확인)</li>
<li>kubectl apply -f path-based-ingress.yaml</li>
<li>kubectl get ingress -n ingress-basic</li>
</ul>
</li>
<li>Ingress 테스트
<ul>
<li>API Gateway 주소를 Local 시스템에 등록</li>
<li>Windows - hosts 파일 맨 하단에 Ingress Controller의 External-IP 등록</li>
</ul>
</li>
</ul>
</li>
<li><b>Metric Server 설치</b>
<ul>
<li>kubectl apply -f <a href="https://github.com/kubernetes-sigs/metrics-server/releases/download/v0.3.7/components.yaml">https://github.com/kubernetes-sigs/metrics-server/releases/download/v0.3.7/components.yaml</a></li>
<li>kubectl get deployment metrics-server -n kube-system</li>
</ul>
</li>
<li><b>AWS EKS 모니터링</b>
<ul>
<li>Metric-Server 설치
<ul>
<li>kubectl apply -f <a href="https://github.com/kubernetes-sigs/metrics-server/releases/download/v0.5.0/components.yaml">https://github.com/kubernetes-sigs/metrics-server/releases/download/v0.5.0/components.yaml</a></li>
</ul>
</li>
<li>Kubernetes DashBoard 설치
<ul>
<li>kubectl apply -f <a href="https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-beta8/aio/deploy/recommended.yaml">https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-beta8/aio/deploy/recommended.yaml</a></li>
</ul>
</li>
<li>eks-admin 서비스 계정 및 클러스터 롤 바인딩 생성<pre style="white-space: pre-wrap">
cat &#60;&#60;EOF | kubectl apply -f -
  apiVersion: v1
  kind: ServiceAccount
  metadata:
    name: eks-admin
    namespace: kube-system
  &#45;&#45;&#45;
  apiVersion: rbac.authorization.k8s.io/v1beta1
  kind: ClusterRoleBinding
  metadata:
    name: eks-admin
  roleRef:
    apiGroup: rbac.authorization.k8s.io
    kind: ClusterRole
    name: cluster-admin
  subjects:
  - kind: ServiceAccount
    name: eks-admin
    namespace: kube-system
EOF
</pre>
</li>
<li>인증 토큰 조회
<ul>
<li>
<pre style="white-space: pre-wrap">kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep eks-admin | awk "{print $1}")</pre>
</li>
</ul>
</li>
<li>Proxy 설정 및 DashBoard 연결
<ul>
<li>kubectl proxy</li>
<li><a href="http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/#!/login">http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/#!/login</a></li>
<li>복사한 토큰 정보로 로그인</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</details>
<details>
<summary><b>Real MSA Application Deployment</b></summary>
<ul>
<li>
<p><b>사전작업</b></p>
<ul>
<li>aws ecr get-login-password --region ap-northeast-2 | docker login --username AWS --password-stdin (Account-ID).dkr.ecr.ap-northeast-2.amazonaws.com</li>
<li>cd  ~</li>
<li>mkdir MSA-Sample</li>
<li>cd MSA-Sample</li>
</ul>
</li>
<li>
<p><b>마이크로서비스 배포</b></p>
<ul>
<li>
<p>상품(Product) 서비스</p>
<pre style="white-space: pre-wrap">
export ECR=[AWS_ACCOUNT_ID].dkr.ecr.ap-northeast-2.amazonaws.com
git clone https://github.com/event-storming/reqres_products.git
cd reqres_products
mvn package -Dmaven.test.skip=true
<p>docker build -t ${ECR}/products:latest .<br />
aws ecr create-repository --repository-name products --region ap-northeast-2<br />
docker push ${ECR}/products:latest</p>
<p>kubectl create deploy products --image=${ECR}/products:latest<br />
kubectl expose deploy products --type=ClusterIP&quot; --port=8080<br />
cd …</p>
</pre>
</li>
<li>
<p>주문(Order) 서비스</p>
<pre style="white-space: pre-wrap">
export ECR=[AWS_ACCOUNT_ID].dkr.ecr.ap-northeast-2.amazonaws.com
git clone https://github.com/event-storming/reqres_orders.git
<p>cd reqres_orders<br />
export IMAGENAME=orders<br />
mvn package -Dmaven.test.skip=true<br />
docker build -t <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>E</mi><mi>C</mi><mi>R</mi></mrow><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">{ECR}/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span><span class="mord mathrm">/</span></span></span></span>{IMAGENAME}:latest .<br />
aws ecr create-repository --repository-name ${IMAGENAME} --region ap-northeast-2<br />
docker push <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>E</mi><mi>C</mi><mi>R</mi></mrow><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">{ECR}/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span><span class="mord mathrm">/</span></span></span></span>{IMAGENAME}:latest<br />
kubectl create deploy {IMAGENAME} --image={ECR}/${IMAGENAME}:latest<br />
kubectl expose deploy ${IMAGENAME} --type=ClusterIP&quot; --port=8080</p>
<p>cd …</p>
</pre>
</li>
<li>
<p>배송(Delivery) 서비스</p>
<pre style="white-space: pre-wrap">
git clone https://github.com/event-storming/reqres_delivery.git
cd reqres_delivery
export IMAGENAME=delivery
<p>mvn package -Dmaven.test.skip=true<br />
docker build -t <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>E</mi><mi>C</mi><mi>R</mi></mrow><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">{ECR}/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span><span class="mord mathrm">/</span></span></span></span>{IMAGENAME}:latest .<br />
aws ecr create-repository --repository-name ${IMAGENAME} --region ap-northeast-2<br />
docker push <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>E</mi><mi>C</mi><mi>R</mi></mrow><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">{ECR}/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span><span class="mord mathrm">/</span></span></span></span>{IMAGENAME}:latest<br />
kubectl create deploy {IMAGENAME} --image={ECR}/${IMAGENAME}:latest<br />
kubectl expose deploy ${IMAGENAME} --type=ClusterIP&quot; --port=8080</p>
<p>cd …</p>
</pre>
</li>
<li>
<p>인증(Oauth) 서비스</p>
<pre style="white-space: pre-wrap">
git clone https://github.com/event-storming/oauth.git
cd oauth
export IMAGENAME=oauth
<p>mvn package -Dmaven.test.skip=true<br />
docker build -t <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>E</mi><mi>C</mi><mi>R</mi></mrow><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">{ECR}/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span><span class="mord mathrm">/</span></span></span></span>{IMAGENAME}:latest .<br />
aws ecr create-repository --repository-name ${IMAGENAME} --region ap-northeast-2<br />
docker push <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>E</mi><mi>C</mi><mi>R</mi></mrow><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">{ECR}/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span><span class="mord mathrm">/</span></span></span></span>{IMAGENAME}:latest<br />
kubectl create deploy {IMAGENAME} --image={ECR}/${IMAGENAME}:latest<br />
kubectl expose deploy ${IMAGENAME} --type=ClusterIP&quot; --port=8080</p>
<p>cd …</p>
</pre>
</li>
<li>
<p>게이트웨이(Gateway) 서비스</p>
<pre style="white-space: pre-wrap">
git clone https://github.com/event-storming/gateway.git
cd gateway
export IMAGENAME=gateway
<p>mvn package -Dmaven.test.skip=true<br />
docker build -t <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>E</mi><mi>C</mi><mi>R</mi></mrow><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">{ECR}/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span><span class="mord mathrm">/</span></span></span></span>{IMAGENAME}:latest .<br />
aws ecr create-repository --repository-name ${IMAGENAME} --region ap-northeast-2<br />
docker push <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>E</mi><mi>C</mi><mi>R</mi></mrow><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">{ECR}/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span><span class="mord mathrm">/</span></span></span></span>{IMAGENAME}:latest<br />
kubectl create deploy {IMAGENAME} --image={ECR}/${IMAGENAME}:latest<br />
kubectl expose deploy ${IMAGENAME} --type=“LoadBalancer” --port=8080</p>
<p>cd …</p>
</pre>
</li>
<li>
<p>프론트-엔드(UI) 서비스: 빌드환경 설정(npm 설치)</p>
<pre style="white-space: pre-wrap">
sudo apt-get update
sudo apt install build-essential
curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -
sudo apt install nodejs
</pre>
</li>
<li>
<p>프론트-엔드(UI) 서비스: 배포 사전 작업</p>
<pre style="white-space: pre-wrap">
git clone https://github.com/event-storming/ui.git
cd ui
export IMAGENAME=ui
<p>npm install<br />
npm run build<br />
docker build -t <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>E</mi><mi>C</mi><mi>R</mi></mrow><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">{ECR}/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span><span class="mord mathrm">/</span></span></span></span>{IMAGENAME}:latest .<br />
aws ecr create-repository --repository-name ${IMAGENAME} --region ap-northeast-2<br />
docker push <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>E</mi><mi>C</mi><mi>R</mi></mrow><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">{ECR}/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span><span class="mord mathrm">/</span></span></span></span>{IMAGENAME}:latest</p>
<p>_GATEWAY_IP=$(kubectl get -o jsonpath=&quot;{.status.loadBalancer.ingress[0].hostname}&quot; svc gateway --ignore-not-found)<br />
echo ${_GATEWAY_IP}</p>
</pre>
</li>
<li>
<p>프론트-엔드(UI) 서비스: 배포 및 서비스 생성</p>
<pre style="white-space: pre-wrap">
cat &#60;&#60;EOF | kubectl apply -f -
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ${IMAGENAME}
  labels:
    app: ${IMAGENAME}
spec:
  replicas: 1
  selector:
    matchLabels:
      app: ${IMAGENAME}
  template:
    metadata:
      labels:
        app: ${IMAGENAME}
    spec:
      containers:
        - name: ${IMAGENAME}
          image: ${ACR}/${IMAGENAME}:latest
          ports:
            - containerPort: 8080
          env:
            - name: VUE_APP_API_HOST
              value: http://${_GATEWAY_IP}:8080
EOF
<p>kubectl expose deploy ${IMAGENAME} --type=“LoadBalancer” --port=8080</p>
<p>cd …</p>
</pre>
</li>
</ul>
</li>
<li>
<p><b>서비스 확인</b></p>
<ul>
<li>kubectl get svc ui</li>
<li>브라우저에서 접속 http://UI-Service-EXTERNAL-IP:8080</li>
</ul>
</li>
</ul>
</details>
<details>
<summary><b>Service Mesh, Istio Hands-on</b></summary>
<ul>
<li><b>Lab. Istio Install</b>
<ul>
<li>Istio 설치</li>
<li>curl -L <a href="https://istio.io/downloadIstio">https://istio.io/downloadIstio</a> | ISTIO_VERSION=1.7.1 TARGET_ARCH=x86_64 sh -<br />
&quot;(istio v1.7.1은 Kubernetes 1.16이상에서만 동작)&quot;</li>
<li>cd istio-1.7.1</li>
<li>
<pre style="white-space: pre-wrap">export PATH=$PWD/bin:$PATH</pre>
</li>
<li>istioctl install --set profile=demo --set <a href="http://hub=gcr.io/istio-release">hub=gcr.io/istio-release</a><br />
&quot;note : there are other profiles for production or performance testing.&quot;</li>
<li>Istio 모니터링 툴(Telemetry Applications) 설치
<ul>
<li>
<p>vi samples/addons/kiali.yaml</p>
</li>
<li>
<p>4라인의 apiVersion: <a href="http://apiextensions.k8s.io/v1beta1%EC%9D%84">apiextensions.k8s.io/v1beta1을</a> apiVersion: <a href="http://apiextensions.k8s.io/v1%EC%9C%BC%EB%A1%9C">apiextensions.k8s.io/v1으로</a> 수정</p>
</li>
<li>
<p>kubectl apply -f samples/addons</p>
</li>
<li>
<p>kiali.yaml 오류발생시, 아래 명령어 실행</p>
<blockquote>
<p>kubectl apply -f <a href="https://raw.githubusercontent.com/istio/istio/release-1.7/samples/addons/kiali.yaml">https://raw.githubusercontent.com/istio/istio/release-1.7/samples/addons/kiali.yaml</a></p>
</blockquote>
</li>
<li>
<p>모니터링(Tracing &amp; Monitoring) 툴 설정</p>
<ul>
<li>Monitoring Server - Kiali
<ul>
<li>기본 ServiceType 변경 : ClusterIP를 LoadBalancer 로…
<ul>
<li>kubectl edit svc kiali -n istio-system</li>
<li>:%s/ClusterIP/LoadBalancer/g</li>
<li>:wq!</li>
</ul>
</li>
<li>모니터링 시스템(kiali) 접속 : EXTERNAL-IP:20001 (admin/admin)</li>
</ul>
</li>
<li>Tracing Server - Jaeger
<ul>
<li>기본 ServiceType 변경 : ClusterIP를 LoadBalancer 로…
<ul>
<li>kubectl edit svc tracing -n istio-system</li>
<li>:%s/ClusterIP/LoadBalancer/g</li>
<li>:wq!</li>
</ul>
</li>
<li>분산추적 시스템(tracing) 접속 : EXTERNAL-IP:80</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>설치확인
<ul>
<li>kubectl get all -n istio-system</li>
</ul>
</li>
</ul>
</li>
<li><b>How to enable Istio</b>
<ul>
<li>
<ol>
<li>Whenever deploying to Cluster, Using pre-processing command “Istio kube-inject”</li>
</ol>
<ul>
<li>kubectl apply -f &lt;(istioctl kube-inject -f Deployment.yml) -n istio-test-ns</li>
</ul>
</li>
<li>
<ol start="2">
<li>Using Istio-enabled Namespace.</li>
</ol>
<ul>
<li>e.g. kubectl label namespace tutorial istio-injection=enabled</li>
</ul>
</li>
</ul>
</li>
<li><b>Lab. Istio Tutorial 셋업</b>
<ul>
<li>Git repository에서 Tutorial 리소스 가져오기
<ul>
<li>cd ~</li>
<li>git clone <a href="https://github.com/redhat-developer-demos/istio-tutorial">https://github.com/redhat-developer-demos/istio-tutorial</a></li>
<li>cd istio-tutorial</li>
</ul>
</li>
<li>네임스페이스 생성
<ul>
<li>kubectl create namespace tutorial</li>
</ul>
</li>
<li>Customer Service 배포
<ul>
<li>kubectl apply -f &lt;(istioctl kube-inject -f customer/kubernetes/Deployment.yml) -n tutorial
<ul>
<li>kubectl describe pod (Customer Pod) -n tutorial 로 생성확인</li>
</ul>
</li>
<li>kubectl create -f customer/kubernetes/Service.yml -n tutorial</li>
</ul>
</li>
<li>Istio Gateway 설치 및 Customer 서비스 라우팅(VirtualService) 설정
<ul>
<li>cat customer/kubernetes/Gateway.yml</li>
<li>kubectl create -f customer/kubernetes/Gateway.yml -n tutorial</li>
<li>(Istio-IngressGateway를 통한 Customer 서비스 확인)
<ul>
<li>kubectl get service/istio-ingressgateway -n istio-system</li>
<li>해당 EXTERNAL-IP가 Istio Gateway 주소</li>
<li>Customer 서비스 호출 :<pre style="white-space: pre-wrap">"http://(istio-ingressgateway IP)/customer"</pre>
</li>
</ul>
</li>
</ul>
</li>
<li>Preference, Recommendation-v1 Service 배포
<ul>
<li>kubectl apply -f &lt;(istioctl kube-inject -f preference/kubernetes/Deployment.yml)  -n tutorial</li>
<li>kubectl create -f preference/kubernetes/Service.yml -n tutorial</li>
<li>kubectl apply -f &lt;(istioctl kube-inject -f recommendation/kubernetes/Deployment.yml) -n tutorial</li>
<li>kubectl create -f recommendation/kubernetes/Service.yml -n tutorial</li>
</ul>
</li>
</ul>
</li>
<li><b>Lab. Istio - Traffic Routing</b>
<ul>
<li>Simple Routing
<ul>
<li>(pwd 로 현 위치가 /istio-tutorial/ 인지 확인)</li>
<li>(recommendation 서비스 추가 배포: v2)
<ul>
<li>kubectl apply -f &lt;(istioctl kube-inject -f recommendation/kubernetes/Deployment-v2.yml) -n tutorial</li>
</ul>
</li>
<li>서비스 호출
<ul>
<li>브라우저에서 Customer 서비스(Externl-IP:8080 접속) 호출</li>
<li>F5(새로고침)를 10회 이상 클릭하여 다수의 요청 생성</li>
</ul>
</li>
<li>Routing 결과 확인 - Kiali(Externl-IP:20001) 접속</li>
</ul>
</li>
<li>(Recommendation v.2 서비스 Scale Out)</li>
<li>(서비스의 v2 의 replica 를 2로 설정)
<ul>
<li>kubectl scale --replicas=2 deployment/recommendation-v2 -n tutorial</li>
<li>kubectl get po -n tutorial</li>
</ul>
</li>
<li>Customer 서비스를 10회 이상 F5(새로고침)하여 서비스 호출</li>
<li>Routing 결과 확인 - Kiali(Externl-IP:20001) 접속</li>
<li>Advanced Routing
<ul>
<li>정책(VirtualService, DestinationRule) 설정
<ul>
<li>(현, 정책 확인)
<ul>
<li>kubectl get VirtualService -n tutorial -o yaml</li>
<li>kubectl get DestinationRule -n tutorial -o yaml</li>
</ul>
</li>
<li>(사용자 선호도에 따른 추천 서비스 라우팅 정책 설정)</li>
<li>(VirtualService, DestinationRule 설정, v2로 100% 라우팅)
<ul>
<li>kubectl create -f istiofiles/destination-rule-recommendation-v1-v2.yml -n tutorial</li>
<li>kubectl create -f istiofiles/virtual-service-recommendation-v2.yml -n tutorial</li>
</ul>
</li>
<li>(설정정책 확인)
<ul>
<li>kubectl get VirtualService -n tutorial -o yaml</li>
<li>kubectl get DestinationRule -n tutorial -o yaml</li>
</ul>
</li>
<li>(서비스 확인)
<ul>
<li>브라우저에서 Customer 서비스(Externl-IP:8080 접속)호출</li>
<li>Kiali(Externl-IP:20001), Jaeger(External-IP:80)에서 모니터링</li>
</ul>
</li>
</ul>
</li>
<li>가중치 기반 스마트 라우팅
<ul>
<li>(recommendation 서비스 v1의 가중치를 100으로 변경)
<ul>
<li>kubectl replace -f istiofiles/virtual-service-recommendation-v1.yml -n tutorial</li>
</ul>
</li>
<li>(서비스 호출 및 Kiali(Externl-IP:20001)에서 모니터링)</li>
<li>(VirtualService 삭제 시, Round-Robin 방식으로 동작)
<ul>
<li>kubectl delete -f istiofiles/virtual-service-recommendation-v1.yml -n tutorial</li>
</ul>
</li>
<li>Canary 라우팅 비율별 배포 정책 예시
<ul>
<li>(90 : 10)</li>
<li>kubectl apply -f istiofiles/virtual-service-recommendation-v1_and_v2.yml -n tutorial</li>
<li>(75 : 25)</li>
<li>kubectl replace -f istiofiles/virtual-service-recommendation-v1_and_v2_75_25.yml -n tutorial</li>
</ul>
</li>
<li>삭제
<ul>
<li>kubectl delete dr recommendation -n tutorial</li>
<li>#kubectl delete vs recommendation -n tutorial</li>
<li>kubectl scale --replicas=1 deployment/recommendation-v2 -n tutorial</li>
</ul>
</li>
</ul>
</li>
<li>Client 브라우저 유형별 스마트 라우팅
<ul>
<li>Firefox 브라우저로 접속 시, v2로 라우팅되도록 설정
<ul>
<li>kubectl apply -f istiofiles/destination-rule-recommendation-v1-v2.yml -n tutorial</li>
<li>kubectl apply -f istiofiles/virtual-service-firefox-recommendation-v2.yml -n tutorial</li>
</ul>
</li>
<li>(Firefox 브라우저와 다른 브라우저에서 접속 확인)</li>
<li>(Browser 환경이 지원되지 않을 경우,)
<ul>
<li>curl -A Safari Externl-IP:8080</li>
<li>curl -A Firefox Externl-IP:8080</li>
</ul>
</li>
<li>삭제
<ul>
<li>kubectl delete dr recommendation -n tutorial</li>
<li>kubectl delete vs recommendation -n tutorial</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><b>Lab. Istio - Timeout &amp; Retry</b>
<ul>
<li>Lab에 필요한 모듈(Message Queue) 설치
<ul>
<li>kubectl get svc my-kafka -n kafka</li>
<li>미설치시, 설치 링크 (<a href="https://workflowy.com/s/msa/27a0ioMCzlpV04Ib#/a7018fb8c629">https://workflowy.com/s/msa/27a0ioMCzlpV04Ib#/a7018fb8c629</a>)</li>
</ul>
</li>
<li>tutorial  네임스페이스에 Istio 기능 추가
<ul>
<li>kubectl label namespace tutorial istio-injection=enabled --overwrite</li>
<li>네임스페이스가 없을 시, 생성 후 실행</li>
</ul>
</li>
<li>Lab. Timeout : Fail-Fast를 통한 서비스 Caller 자원 보호
<ul>
<li>Timeout 테스트를 위해 CNA 과정에서 구현한 Order 마이크로서비스의  코드 보완 및 tutorial 네임스페이스에 배포
<ul>
<li>Service time delay를 위해, Order Aggregate(Order.java)에 저장전 Thread.sleep 코드 삽입<pre style="white-space: pre-wrap">
@PrePersist
  public void onPrePersist(){
    try {
        Thread.currentThread().sleep((long) (800 + Math.random() * 220));
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
  }
</pre>
</li>
<li>Docker image Build &amp; Push</li>
<li>tutorial 네임스페이스에 Order v2 서비스 재배포<pre style="white-space: pre-wrap">
kubectl apply -f - &#60;&#60;EOF
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: order
    namespace: tutorial
    labels:
      app: order
  spec:
    replicas: 1
    selector:
      matchLabels:
        app: order
    template:
      metadata:
        labels:
          app: order
      spec:
        containers:
          - name: order
            image: IMAGE_FULL_REPOSITORY_URL/order:v2
            ports:
              - containerPort: 8080
            resources:
              limits:
                cpu: 500m
              requests:
                cpu: 200m
EOF
</pre>
</li>
<li>Order 서비스 생성
<ul>
<li>kubectl expose deploy order --port=8080 -n tutorial</li>
</ul>
</li>
<li>Order 서비스 Timeout 설정 (Istio Gateway에서 Order 서비스로 라우팅 시)
<ul>
<li>(pwd 로 현 위치가 /istio-tutorial/ 인지 확인)</li>
<li>nano customer/kubernetes/Gateway.yaml 오픈 후 마지막 행 다음에 타임아웃 설정이 포함된 아래 내용 추가<pre style="white-space: pre-wrap">
- match:
    - uri:
        prefix: /orders
    route:
    - destination:
        host: order
        port:
          number: 8080
    timeout: 3s
</pre>
</li>
<li>(변경 내용 적용)</li>
<li>kubectl apply -f customer/kubernetes/Gateway.yml -n tutorial</li>
</ul>
</li>
<li>Order 서비스 Timeout 설정 (클라우드 내에서 Order 서비스로 라우팅시)<pre style="white-space: pre-wrap">
kubectl apply -f - &#60;&#60;EOF
    apiVersion: networking.istio.io/v1alpha3
    kind: VirtualService
    metadata:
      name: vs-order-network-rule
      namespace: tutorial
    spec:
      hosts:
      - order
      http:
      - route:
        - destination:
            host: order
        timeout: 3s
EOF
</pre>
</li>
<li>부하테스트 툴(Siege) 설치 및 Order 서비스 Load Testing
<ul>
<li>kubectl run siege --image=apexacme/siege-nginx -n tutorial</li>
<li>kubectl exec -it siege -c siege -n tutorial -- /bin/bash</li>
<li>
<pre style="white-space: pre-wrap">siege -c30 -t20S -v --content-type "application/json" 'http://order:8080/orders POST {"productId": "1001", "qty":5}'</pre>
</li>
</ul>
</li>
</ul>
</li>
<li>Order 서비스에 설정된 Timeout을 임계치를 초과하는 순간, Istio에서 서비스로의 연결을 자동 차단하는 것을 확인</li>
</ul>
</li>
<li>Lab. Retry : 5xx 오류를 리턴받게 되면, Envoy Proxy에서 설정한 횟수만큼 대상 서비스를 재호출하여 일시적인 장애였는지를 다시 확인하는 Rule
<ul>
<li>Retry 테스트를 위해 CNA 과정에서 구현한 Delivery 마이크로서비스를 tutorial 네임스페이스에 배포</li>
<li>Docker image Build &amp; Push</li>
<li>tutorial 네임스페이스에 Delivery 서비스 배포<pre style="white-space: pre-wrap">
kubectl apply -f - &#60;&#60;EOF
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: delivery
    namespace: tutorial
    labels:
      app: delivery
  spec:
    replicas: 1
    selector:
      matchLabels:
        app: delivery
    template:
      metadata:
        labels:
          app: delivery
      spec:
        containers:
          - name: delivery
            image: IMAGE_FULL_REPOSITORY_URL/delivery:v2
            ports:
              - containerPort: 8080
            resources:
              limits:
                cpu: 500m
              requests:
                cpu: 200m
EOF
</pre>
</li>
<li>Delivery 서비스 생성
<ul>
<li>kubectl expose deploy delivery --port=8080 -n tutorial</li>
</ul>
</li>
<li>Order 서비스에 Retry Rule 추가 적용<pre style="white-space: pre-wrap">
kubectl apply -f - &#60;&#60;EOF
  apiVersion: networking.istio.io/v1alpha3
  kind: VirtualService
  metadata:
    name: vs-order-network-rule
    namespace: tutorial
  spec:
    hosts:
    - order
    http:
    - route:
      - destination:
          host: order
      timeout: 3s
      retries:
        attempts: 3
        perTryTimeout: 2s
        retryOn: 5xx,retriable-4xx,gateway-error,connect-failure,refused-stream
EOF
</pre>
</li>
<li>Delivery 서비스를 정지하고, 이를 동기호출하는 Order 서비스 API 호출
<ul>
<li>kubectl scale deploy delivery --replicas=0 -n tutorial</li>
<li>kubectl exec -it siege -c siege -n tutorial --/bin/bash</li>
<li>http <a href="http://order:8080/orders/">http://order:8080/orders/</a> productId=1001 qty=5
<ul>
<li>httpie가 없을 시,</li>
<li>apt-get update</li>
<li>apt-get install httpie</li>
</ul>
</li>
<li>http DELETE <a href="http://order:8080/orders/1">http://order:8080/orders/1</a></li>
</ul>
</li>
<li>Jaeger 접속(<a href="http://tracing">http://tracing</a> svc EXTERNAL-IP :80) 후, Retry 횟수 확인하기<br />
&quot;&lt; 검색조건 &gt;<br />
Service : order.tutorial, Operation : delivery.tutorial.svc.cluster.local:8080/*<br />
검색결과 : 총 Retry 횟수 + 1 의 Requests 로깅&quot;</li>
</ul>
</li>
</ul>
</li>
<li><b>Lab. Istio - Circuit Breaker</b>
<ul>
<li>Circuit Breaker : 장애 인스턴스를 회피하는 기능으로 5xx 오류를 리턴한 인스턴스를  라우팅 대상에서 일정시간 만큼 제외 (Pool Ejection)</li>
<li>Namespace 생성 및 Istio 활성
<ul>
<li>kubectl create namespace istio-cb-ns</li>
<li>kubectl label namespace istio-cb-ns istio-injection=enabled</li>
</ul>
</li>
<li>Istio Retry 디폴트 동작 확인
<ul>
<li>테스트 어플리케이션 배포
<ul>
<li>hello-server-1, hello-server-2 Pods, Service</li>
<li>hello-server 앱은 env:RANDOM_ERROR 값의 확률로 랜덤하게 503 에러를 발생하는 로직이 포함<pre style="white-space: pre-wrap">
kubectl apply -f - &#60;&#60; EOF
    apiVersion: v1
    kind: Pod
    metadata:
      name: hello-server-1
      namespace: istio-cb-ns
      labels:
        app: hello
    spec:
      containers:
      - name: hello-server-1
        image: docker.io/honester/hello-server:latest
        imagePullPolicy: IfNotPresent
        env:
        - name: VERSION
          value: "v1"
        - name: LOG
          value: "1"
    &#45;&#45;&#45;
    apiVersion: v1
    kind: Pod
    metadata:
      name: hello-server-2
      namespace: istio-cb-ns
      labels:
        app: hello
    spec:
      containers:
      - name: hello-server-2
        image: docker.io/honester/hello-server:latest
        imagePullPolicy: IfNotPresent
        env:
        - name: VERSION
          value: "v2"
        - name: LOG
          value: "1"
        - name: RANDOM_ERROR
          value: "0.2"
    &#45;&#45;&#45;
    apiVersion: v1
    kind: Service
    metadata:
      name: svc-hello
      namespace: istio-cb-ns
      labels:
        app: hello
    spec:
      selector:
        app: hello
      ports:
      - name: http
        protocol: TCP
        port: 8080
EOF
</pre>
</li>
<li>클라이언트용 서비스(httpbin) 배포<pre style="white-space: pre-wrap">
kubectl apply -f - &#60;&#60;EOF
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: httpbin
      namespace: istio-cb-ns
    spec:
      replicas: 1
      selector:
        matchLabels:
          app: httpbin
      template:
        metadata:
          labels:
            app: httpbin
        spec:
          containers:
          - name: httpbin
            image: docker.io/honester/httpbin:latest
            imagePullPolicy: IfNotPresent
            ports:
            - containerPort: 80
    &#45;&#45;&#45;
    apiVersion: v1
    kind: Service
    metadata:
      name: httpbin
      namespace: istio-cb-ns
      labels:
        app: httpbin
    spec:
      selector:
        app: httpbin
      ports:
      - name: http
        port: 8000
        targetPort: 80
EOF
</pre>
</li>
</ul>
</li>
<li>Retry 디폴트 동작 테스트
<ul>
<li>hello-server-2의 로그 모니터 걸기
<ul>
<li>kubectl logs -f hello-server-2 -c hello-server-2 -n istio-cb-ns</li>
</ul>
</li>
<li>클라이언트에서 svc-hello 서비스 10번 호출하기
<ul>
<li>for i in {1…10}; do kubectl exec -it httpbin -c httpbin -n istio-cb-ns --curl http://svc-hello.istio-cb-ns:8080; sleep 0.1; done</li>
</ul>
</li>
</ul>
</li>
<li>결과 확인/분석<br />
&quot;1) 서비스 호출은 Round Robin으로 로드 밸런싱되나, 프로세싱 시간에 따라 동일한 서비스가 연속 2회 로깅 될 수 있음
<ol start="2">
<li>핵심포인트는, Server-2가 5xx 오류를 리턴할 경우, 자동으로 Retry되어 Server-1 로그가 연달아 출력된다는 점임. (Default Retry : 2회)&quot;</li>
</ol>
</li>
</ul>
</li>
<li>Circuit Breaker 설정
<ul>
<li>대기 쓰레드수 기반 Circuit Breaker
<ul>
<li>클라이언트용 서비스(httpbin)에 쓰레드 기반 Circuit Breaker 설정</li>
<li>(Pending Thread가 많을수록 경우, 오랫동안 큐잉된 요청은 Response time이 증가하게 되므로, 적절한 대기 쓰레드를 풀을 적용하여 Circuit Breaking)<pre style="white-space: pre-wrap">
kubectl apply -f - &#60;&#60;EOF
  apiVersion: networking.istio.io/v1alpha3
  kind: DestinationRule
  metadata:
    name: dr-httpbin
    namespace: istio-cb-ns
  spec:
    host: httpbin
    trafficPolicy:
      connectionPool:
        http:
          http1MaxPendingRequests: 1
          maxRequestsPerConnection: 1
EOF
</pre>
</li>
<li>Circuit Breaker 동작 확인
<ul>
<li>부하테스트 툴(Siege) 설치 및  Load Testing
<ul>
<li>kubectl run siege --image=apexacme/siege-nginx -n istio-cb-ns</li>
<li>kubectl exec -it siege -c siege -n istio-cb-ns --/bin/bash
<ul>
<li>siege -c1 -t10S -v <a href="http://httpbin:8000/get">http://httpbin:8000/get</a>  # 100% availability</li>
<li>siege -c2 -t10S -v <a href="http://httpbin:8000/get">http://httpbin:8000/get</a>  # 87% availability</li>
</ul>
</li>
</ul>
</li>
<li>Kiali(Externl-IP:20001) 모니터링</li>
</ul>
</li>
</ul>
</li>
<li>로드 밸런싱 풀(pool) 인스턴스의 Health Status 기반 Circuit Breaker
<ul>
<li>Hello 서비스의 로드 밸런싱 풀(pool)의 인스턴스 상태기반 Circuit Breaker 설정<pre style="white-space: pre-wrap">
kubectl apply -f - &#60;&#60;EOF
  apiVersion: networking.istio.io/v1alpha3
  kind: DestinationRule
  metadata:
    name: dr-hello-server
    namespace: istio-cb-ns
  spec:
    host: svc-hello
    trafficPolicy:
      outlierDetection:
        interval: 1s
        consecutiveErrors: 1
        baseEjectionTime: 3m
        maxEjectionPercent: 100
EOF
</pre>
</li>
<li>Circuit Breaker 동작 확인
<ul>
<li>클라이언트(httpbin Pod)에서 svc-hello 호출
<ul>
<li>hello-server-2의 로그 모니터 걸기
<ul>
<li>kubectl logs -f hello-server-2 -c hello-server-2 -n istio-cb-ns</li>
</ul>
</li>
<li>클라이언트에서 svc-hello 서비스 10번 호출하기
<ul>
<li>for i in {1…10}; do kubectl exec -it httpbin -c httpbin -n istio-cb-ns --curl http://svc-hello.istio-cb-ns:8080; sleep 0.1; done</li>
</ul>
</li>
<li>결과 확인/분석<br />
&quot;1) 5초 동안 5xx 에러가 2번 발생할 경우, Server-2로는 5분 동안 트래픽이 라우팅 되지 않는다.
<ol start="2">
<li>모니터링 시스템(Kiali) : EXTERNAL-IP:20001 에서 Circuit Breaker 뱃지 발생 확인&quot;</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>동기호출 Target인 배송(Delivery) 서비스에 Circuit Breaker 설정하기
<ul>
<li>Thread 부하 및 5XX 오류에 대해 서비스를 차단하는 Circuit Breaker 생성<pre style="white-space: pre-wrap">
kubectl apply -f - &#60;&#60;EOF
  apiVersion: networking.istio.io/v1alpha3
  kind: DestinationRule
  metadata:
    name: dr-delivery
    namespace: tutorial
  spec:
    host: delivery
    trafficPolicy:
      connectionPool:
        http:
          http1MaxPendingRequests: 30
          maxRequestsPerConnection: 100
      outlierDetection:
        interval: 5s
        consecutiveErrors: 1
        baseEjectionTime: 5m
        maxEjectionPercent: 100
EOF
</pre>
</li>
<li>설정 내용
<ul>
<li>최대 활성 연결 갯수 30개와 최대 요청 대기 수를 100개로 지정하고, 이 임계점을 넘어가는 추가 요청은 거부(circuit break)</li>
<li>5초 동안 2번 5xx을 리턴한 서비스는 5분 동안 라우팅 대상에서 제외(Ejection)</li>
<li>또한, 모든 대상 서비스 인스턴스가 방출(제외)될 수 있음</li>
</ul>
</li>
</ul>
</li>
<li>Clean-up
<ul>
<li>kubectl delete pod/hello-server-1 pod/hello-server-2 pod/httpbin service/svc-hello dr/dr-hello -n istio-cb-ns</li>
</ul>
</li>
</ul>
</li>
<li><b>Clear Istio </b>
<ul>
<li>kubectl delete ns tutorial istio-cb-ns istio-system</li>
</ul>
</li>
</ul>
</details>
<details>
<summary><b>Backup</b></summary>
<ul>
<li>
<p><b>Container로부터 이미지 생성</b></p>
<ul>
<li>이미지 생성
<ul>
<li>docker run --name my-nginx -d -p 80:80 nginx</li>
<li>docker exec -it my-nginx /bin/bash
<ul>
<li>apt-get update</li>
<li>apt-get install curl</li>
<li>cd /usr/share/nginx/html</li>
<li>
<pre style="white-space: pre-wrap">echo "Hello my name is PYJ." >> index.html</pre>
</li>
<li>exit</li>
</ul>
</li>
<li>docker commit my-nginx my-nginx:1.0 # 컨테이너를 이미지로 생성</li>
<li>docker diff [실행중인 Container ID] #원본 이미지와의 차이점 확인</li>
<li>
<pre style="white-space: pre-wrap">docker commit -a "apex@naver.com" -m "update nginx" my-nginx my-nginx:1.0 </pre>
</li>
<li>docker images</li>
<li>docker stop my-nginx</li>
<li>docker run --name my-nginx2 -p 80:80 -d my-nginx:1.0</li>
<li><a href="http://localhost">http://localhost</a> 확인</li>
<li>docker stop my-nginx2</li>
</ul>
</li>
<li>이미지 푸시
<ul>
<li>docker tag my-nginx:1.0 apexacme/my-nginx:1.0</li>
<li>docker images</li>
<li>docker push apexacme/my-nginx:1.0</li>
<li><a href="http://hub.docker.com">http://hub.docker.com</a> 에서 이미지 확인</li>
</ul>
</li>
<li>도커허브 이미지로부터 컨테이너 실행
<ul>
<li>docker run --name new-nginx -d -p 80:80 apexacme/my-nginx:1.0</li>
</ul>
</li>
</ul>
</li>
<li>
<p><b>샘플 자바 애플리케이션 패키징과 배포 </b></p>
<ul>
<li>(pwd 로 현 위치가 /container-orchestration_aws/ 인지 확인)</li>
<li>git clone <a href="https://github.com/event-storming/monolith.git">https://github.com/event-storming/monolith.git</a></li>
<li>cd monolith/</li>
<li>ls</li>
<li>(skip) mvn spring-boot:run #Maven으로 App. 실행</li>
<li>mvn package -B -Dmaven.test.skip=true</li>
<li>(skip) java -jar target/monolith-0.0.1.BUILD-SNAPSHOT.jar #Java로 App. 실행</li>
<li>cat Dockerfile # 도커파일 내용 확인</li>
<li>(도커라이징)
<ul>
<li>docker build -t (Azure container registry명).azurecr.io/monolith:v1 .
<ul>
<li>#주의1 :   명령  맨끝에 &quot; .&quot; 빼먹으면 안됨.   Dockerfile 의 위치인</li>
<li>#주의2 :   project id 부분을 자신의 GCP project id 로 변경!!</li>
<li>#주의3 :   현재 연결된 kubernetes 클러스터와 동일한 프로젝트 id 여야만 gcr registry 접근이 가능함</li>
</ul>
</li>
<li>docker images</li>
<li>(skip) docker run (Azure container registry명).azurecr.io/monolith:v1 #Docker로 App. 실행</li>
<li>docker push (azure container registry명).azurecr.io/monolith:v1</li>
</ul>
</li>
<li>kubectl create deploy monolith --image=(azure container registry명).azurecr.io/monolith:v1</li>
<li>kubectl get po -l app=monolith</li>
<li>
<pre style="white-space: pre-wrap">kubectl expose deploy monolith --type="LoadBalancer" --port=8080</pre>
</li>
<li>kubectl get svc -w</li>
<li>자바 애플리케이션 접속
<ul>
<li>http://(Service_Extern-IP):8080</li>
</ul>
</li>
</ul>
</li>
<li>
<p><b>Lab. Circuit Breaking</b></p>
<ul>
<li>Istio가 활성화된 네임스페이스 생성
<ul>
<li>kubectl create namespace istio-cb-ns</li>
<li>kubectl label namespace istio-cb-ns istio-injection=enabled</li>
</ul>
</li>
<li>[CB 유스케이스] #1. Connection Max &amp; Pending 수에 따른 Circuit Breaker
<ul>
<li>
<p>테스트 어플리케이션 배포 (Deployment, Service)</p>
<pre style="white-space: pre-wrap">
kubectl apply -f - &#60;&#60;EOF
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: httpbin
    namespace: istio-cb-ns
  spec:
    replicas: 1
    selector:
      matchLabels:
        app: httpbin
    template:
      metadata:
        labels:
          app: httpbin
      spec:
        containers:
        - name: httpbin
          image: docker.io/honester/httpbin:latest
          imagePullPolicy: IfNotPresent
          ports:
          - containerPort: 80
  &#45;&#45;&#45;
  apiVersion: v1
  kind: Service
  metadata:
    name: httpbin
    namespace: istio-cb-ns
    labels:
      app: httpbin
  spec:
    selector:
      app: httpbin
    ports:
    - name: http
      port: 8000
      targetPort: 80
EOF
</pre>
</li>
<li>
<p>로드 테스트 툴(siege) 배포</p>
<pre style="white-space: pre-wrap">
kubectl apply -f - &#60;&#60;EOF
  apiVersion: v1
  kind: Pod
  metadata:
    name: siege
    namespace: istio-cb-ns
  spec:
    containers:
    - name: siege
      image: apexacme/siege-nginx
EOF
</pre>
</li>
<li>
<p>siege를 통한 서비스(httpbin) 부하 생성</p>
<ul>
<li>kubectl exec -it siege --container siege -n istio-cb-ns --/bin/bash</li>
<li>siege -c1 -t10S -v <a href="http://httpbin:8000/get">http://httpbin:8000/get</a></li>
<li>siege -c1 -t10S -v http://httpbin.istio-cb-ns:8000/get</li>
<li>siege -c1 -t10S -v <a href="http://httpbin.istio-cb-ns.svc.cluster.local:8000/get">http://httpbin.istio-cb-ns.svc.cluster.local:8000/get</a></li>
<li>서비스 모니터링 (Kiali) : EXTERNAL-IP:20001 (admin/admin)</li>
</ul>
</li>
<li>
<p>DestinationRule 를 생성하여 CB가 발생할 수 있도록 Connection pool 설정</p>
<pre style="white-space: pre-wrap">
kubectl apply -f - &#60;&#60;EOF
  apiVersion: networking.istio.io/v1alpha3
  kind: DestinationRule
  metadata:
    name: dr-httpbin
    namespace: istio-cb-ns
<p>spec:<br />
host: httpbin<br />
trafficPolicy:<br />
connectionPool:<br />
http:<br />
http1MaxPendingRequests: 1<br />
maxRequestsPerConnection: 1<br />
EOF</p>
</pre>
- http1MaxPendingRequests=1 : Queue에서 Connection pool 에 연결을 기다리는 request 수를 1개로 제한
- maxRequestsPerConnection=1 : keep alive 기능 disable
</li>
<li>
<p>siege를 통한 서비스(httpbin) 부하 재생성 및 CB 확인</p>
<ul>
<li>siege -c1 -t10S -v <a href="http://httpbin:8000/get">http://httpbin:8000/get</a>  # 100% Availability</li>
<li>siege -c2 -t10S -v <a href="http://httpbin:8000/get">http://httpbin:8000/get</a>  # 87% availability
<ul>
<li>Envoy will return HTTP 503. It is the responsibility of the application to implement any fallback logic that is needed to handle the HTTP 503 error code from an upstream service. (<a href="https://istio-releases.github.io/v0.1/docs/concepts/traffic-management/handling-failures.html">https://istio-releases.github.io/v0.1/docs/concepts/traffic-management/handling-failures.html</a>)</li>
</ul>
</li>
<li>모니터링 시스템(Kiali) : EXTERNAL-IP:20001 에서 Circuit Breaker 발생 확인 (뱃지)</li>
</ul>
</li>
<li>
<p>Circuit Breaker 제거 후, 동일 로드 생성 후, Availability 100% 확인</p>
<ul>
<li>kubectl delete dr/dr-httpbin -n istio-cb-ns</li>
<li>siege -c2 -t10S -v <a href="http://httpbin:8000/get">http://httpbin:8000/get</a>  # 100% availability</li>
</ul>
</li>
<li>
<p>Clean-up</p>
<ul>
<li>kubectl delete deployment.apps/httpbin service/httpbin -n istio-cb-ns</li>
</ul>
</li>
</ul>
</li>
<li>Istio - Circuit Breaker
<ul>
<li>
<p>테스트 어플리케이션 배포 (hello-server-1, hello-server-2 Pods, Service)</p>
</li>
<li>
<p>(hello-server:latest 이미지는 env:RANDOM_ERROR 값의 확률로 랜덤하게 503 에러를 발생하는 로직이 포함)</p>
<pre style="white-space: pre-wrap">
kubectl apply -f - &#60;&#60;EOF
  apiVersion: v1
  kind: Pod
  metadata:
    name: hello-server-1
    namespace: istio-cb-ns
    labels:
      app: hello
  spec:
    containers:
    - name: hello-server-1
      image: docker.io/honester/hello-server:latest
      imagePullPolicy: IfNotPresent
      env:
      - name: VERSION
        value: "v1"
      - name: LOG
        value: "1"
  &#45;&#45;&#45;
  apiVersion: v1
  kind: Pod
  metadata:
    name: hello-server-2
    namespace: istio-cb-ns
    labels:
      app: hello
  spec:
    containers:
    - name: hello-server-2
      image: docker.io/honester/hello-server:latest
      imagePullPolicy: IfNotPresent
      env:
      - name: VERSION
        value: "v2"
      - name: LOG
        value: "1"
      - name: RANDOM_ERROR
        value: "0.2"
  &#45;&#45;&#45;
  apiVersion: v1
  kind: Service
  metadata:
    name: svc-hello
    namespace: istio-cb-ns
    labels:
      app: hello
  spec:
    selector:
      app: hello
    ports:
    - name: http
      protocol: TCP
      port: 8080
EOF
</pre>
</li>
<li>
<p>클라이언트용 Pod 설치</p>
<pre style="white-space: pre-wrap">
kubectl apply -f - &#60;&#60;EOF
  apiVersion: v1
  kind: Pod
  metadata:
    name: httpbin
    namespace: istio-cb-ns
    labels:
      app: httpbin
  spec:
    containers:
    - name: httpbin
      image: docker.io/honester/httpbin:latest
      imagePullPolicy: IfNotPresent
EOF
</pre>
</li>
<li>
<p>클라이언트(httpbin Pod)에서 svc-hello 호출(default, Round-Robin)</p>
<ul>
<li>(hello-server-2의 로그 모니터링)</li>
<li>kubectl logs -f hello-server-2 -c hello-server-2 -n istio-cb-ns</li>
<li>(클라이언트에서 svc-hello 서비스 10번 호출하기)</li>
<li>for i in {1…10}; do kubectl exec -it httpbin -c httpbin -n istio-cb-ns --curl http://svc-hello.istio-cb-ns:8080; sleep 0.1; done</li>
</ul>
</li>
<li>
<p>5XX 오류에 대해 해당 서비스 차단 및 Thread 부하에 따른 Circuit Breaker 생성</p>
<pre style="white-space: pre-wrap">
kubectl apply -f - &#60;&#60;EOF
  apiVersion: networking.istio.io/v1alpha3
  kind: DestinationRule
  metadata:
    name: dr-delivery
    namespace: istio-cb-ns
  spec:
    host: delivery
    trafficPolicy:
      connectionPool:
        http:
          http1MaxPendingRequests: 1
          maxRequestsPerConnection: 1
      outlierDetection:
        interval: 1s
        consecutiveErrors: 1
        baseEjectionTime: 3m
        maxEjectionPercent: 100
EOF

<p>설명 : 1초 주기로 이상징후를 체크하며, 1번이라도 실패한 서비스는 3분동안 라우팅 대상에서 제외된다. 또한 모든 대상 서비스 인스턴스가 방출(제외)될 수 있다.&quot;</p>
</pre>
</li>
<li>
<p>클라이언트(httpbin Pod)에서 svc-hello 호출 및 CB 확인</p>
<ul>
<li>(hello-server-2의 로그 모니터링)</li>
<li>kubectl logs -f hello-server-2 -c hello-server-2 -n istio-cb-ns</li>
<li>(클라이언트에서 svc-hello 서비스 10번 호출하기)</li>
<li>for i in {1…10}; do kubectl exec -it httpbin -c httpbin -n istio-cb-ns --curl http://svc-hello.istio-cb-ns:8080; sleep 0.1; done</li>
<li>모니터링 시스템(Kiali) : EXTERNAL-IP:20001 에서 Circuit Breaker 발생 확인 (뱃지)</li>
</ul>
</li>
<li>
<p>Clean-up</p>
<ul>
<li>kubectl delete pod/hello-server-1 pod/hello-server-2 pod/httpbin service/svc-hello dr/dr-hello -n istio-cb-ns</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><b>Lab. Istio Egress</b></p>
<ul>
<li>외부 도메인을 호출하는 v3 버전을 배포
<ul>
<li>kubectl apply -f &lt;(istioctl kube-inject -f recommendation/kubernetes/Deployment-v3.yml) -n tutorial</li>
</ul>
</li>
<li>브라우저에서 Customer 서비스(Externl-IP:8080 접속)</li>
<li>v3에서 날짜정보가 추가로 출력됨을 확인</li>
<li>Istio 트래픽을 등록된 것만 허용하도록 변경
<ul>
<li>
<pre style="white-space: pre-wrap">kubectl get configmap istio -n istio-system -o yaml | sed "s/mode: ALLOW_ANY/mode: REGISTRY_ONLY/g" | kubectl replace -n istio-system -f -</pre>
</li>
</ul>
</li>
<li>브라우저에서 Customer 서비스(Externl-IP:8080 접속)
<ul>
<li>v3 은 서비스 오류로 인해 브라우저 확인 불가, Kiali 에서 확인</li>
</ul>
</li>
<li>트래픽을 모두 v3 (weigh 100)로 라우팅하고 에러 화면 확인
<ul>
<li>kubectl create -f istiofiles/destination-rule-recommendation-v1-v2-v3.yml -n tutorial</li>
<li>kubectl create -f istiofiles/virtual-service-recommendation-v3.yml -n tutorial</li>
</ul>
</li>
<li>브라우저에서 Customer 서비스(Externl-IP:8080 접속)
<ul>
<li>화면에 Error Log 출력 : “customer =&gt; Error: 503 - preference =&gt; Error: 500”</li>
</ul>
</li>
<li>외부 도메인을 허용해 주는 ServiceEntry 를 생성하여 정상 접속 허용
<ul>
<li>kubectl create -f istiofiles/service-entry-egress-worldclockapi.yml -n tutorial</li>
<li>브라우저에서 Customer 서비스(Externl-IP:8080 접속) - 정상 출력</li>
</ul>
</li>
<li>(테스트 후, 설정 복구)</li>
<li>
<pre style="white-space: pre-wrap">kubectl get configmap istio -n istio-system -o yaml | sed "s/mode: REGISTRY_ONLY/mode: ALLOW_ANY/g" | kubectl replace -n istio-system -f -</pre>
</li>
</ul>
</li>
</ul>
</details>
</p>
</details>
<hr />
<br />
</div></div></div></div></div></main></div><!----><div class=" bottom-0 right-0 z-50 p-8 " style="position: fixed; z-index:999;"><button class="p-3 text-white rounded-full shadow-lg bg-ui-primary hover:text-white"><svg xmlns="http://www.w3.org/2000/svg" width="24px" height="24px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button></div></div>
    <script src="/assets/js/app.3663d38e.js" defer></script><script src="/assets/js/page--src--templates--vue-page-vue.bf23a17a.js" defer></script>
  </body>
</html>
