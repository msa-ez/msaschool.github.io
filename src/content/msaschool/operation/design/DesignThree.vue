<template>
    <div>
        <div style = "height:30px; width:100%; margin-top:20px;">
                <VueSubLayoutCard lab="ddd-google-drive-associate"></VueSubLayoutCard>
        </div>
        <mark-down class="content">
## Eventstorming (이벤트스토밍)

### 이벤트스토밍이란?

DDD(Domain-Driven Design, 도메인 주도 설계)는 비즈니스 도메인의 개념을 코드에 반영하여 개발자와 도메인 전문가 간의 소통을 원활하게 하고, 소프트웨어가 비즈니스 요구사항을 잘 반영할 수 있도록 지원하는 것을 목표로 합니다.

이벤트스토밍(Event Storming)은 DDD의 원칙을 실질적으로 적용할 수 있는 실천법으로, DDD의 핵심 개념 중 하나인 도메인 이벤트(Domain Event)를 중심으로 도메인을 시각화하고, 이를 통해 복잡한 시스템을 설계하는 방법입니다. 

이 기법은 모든 이해관계자(개발자, 도메인 전문가, 비즈니스 리더 등)가 협력하여 도메인의 상태 변화를 도출하고, 이를 기반으로 마이크로서비스를 설계할 수 있는 혁신적인 표준 방법론입니다.

### 이벤트스토밍과 DDD의 관계:

1. **도메인 복잡성 관리**: DDD는 복잡한 도메인의 관리에 중점을 두고 있으며, 이벤트스토밍은 이러한 복잡성을 시각적으로 분해하고, 이해관계자 간에 공유된 이해를 통해 문제를 해결할 수 있게 합니다.

2. **도메인 이벤트 중심 설계**: DDD에서는 비즈니스의 중요한 상태 변화를 나타내는 도메인 이벤트를 중심으로 모델링을 합니다. 이벤트스토밍은 이러한 도메인 이벤트를 시각적으로 표현하고, 이벤트 간의 관계를 이해하는 과정을 통해 DDD의 도메인 모델링을 쉽게 시작할 수 있도록 지원합니다.

3. **비즈니스와 기술의 연결**: DDD는 도메인 전문가와 개발자 간의 소통을 중요하게 생각합니다. 이벤트스토밍은 이를 실제로 구현할 수 있는 도구로, 모든 이해관계자가 함께 모여 도메인 이벤트를 정의하고, 이를 통해 도메인 모델을 구축합니다. 이는 비즈니스 요구사항이 소프트웨어 설계에 명확히 반영되도록 보장합니다.

4. **바운디드 컨텍스트와 애그리거트 정의**: DDD의 중요한 개념인 바운디드 컨텍스트와 애그리거트를 정의하는 데에도 이벤트스토밍이 효과적입니다. 이벤트스토밍을 통해 도출된 도메인 이벤트들은 바운디드 컨텍스트와 애그리거트의 경계를 설정하는 데 사용됩니다.

### 기존 설계 방식과 이벤트스토밍의 차이점:
        </mark-down>
        <g-image src="https://github.com/user-attachments/assets/a20bdb44-3809-41a5-baa5-af946684a547" class="pb-2"></g-image>
        <mark-down class="content">
전통적인 소프트웨어 설계 방식은 주로 UML 다이어그램, 워터폴 모델 등의 기술 중심적이고 계층적인 설계 방식을 따릅니다. 이러한 방식은 시스템의 구조적 측면을 강조하며, 명확한 순서와 단계별 진행이 특징입니다. 하지만 이러한 접근은 IT 지식이 부족한 도메인 전문가들이 참여하기에 어려움을 겪을 수 있습니다. 비즈니스 전문가들이 비즈니스 요구사항을 정확하게 전달하고 반영하는 데 한계가 있을 수 있으며, 복잡한 도메인을 충분히 반영하지 못할 가능성이 있습니다.

반면, 이벤트스토밍은 비즈니스 이벤트를 중심으로 도메인을 시각화하여, 비즈니스 전문가와 개발자 모두가 쉽게 참여할 수 있는 환경을 제공합니다. 이 방식은 비즈니스와 기술 간의 격차를 줄이고, 팀 전체가 도메인에 대한 공통된 이해를 가질 수 있도록 돕습니다. 또한, 이벤트스토밍은 도메인 이벤트라는 비즈니스 중심의 접근 방식을 통해 도메인의 복잡성을 관리하고, 협업을 촉진합니다.

이벤트스토밍으로 분리된 각 서브 도메인 내에서는 전통적인 설계 방식을 적용하여 구체적인 UML 다이어그램을 작성합니다. 이 과정에서 이벤트스토밍이 제공하는 비즈니스 이벤트의 시각적 표현은 UML의 정형화된 기술적 다이어그램과 결합되어, 비즈니스와 기술적 요구사항을 동시에 만족시키는 설계를 가능하게 합니다. 
        </mark-down>
        <g-image style="margin-bottom: -50px;" src="https://github.com/user-attachments/assets/96460d08-1f37-45db-846b-4b20d0fe6e22"></g-image>
    <mark-down class="content">
### 이벤트스토밍 준비:

1. **이벤트스토밍을 위한 팀 구성**
이벤트스토밍 세션을 효과적으로 진행하기 위해서는 개발자, 도메인 전문가, 비즈니스 이해관계자 등이 참여해야 합니다. 각자의 역할을 명확히 정의하고, 도메인 지식을 공유하는 것이 중요합니다.

2. **필요한 도구와 자료 준비 (스티커, 마커, 화이트보드 등)**
이벤트스토밍에서는 시각적 표현이 핵심이므로, 다양한 색상의 스티커(포스트잇), 마커, 화이트보드, 그리고 큰 작업 공간이 필요합니다. 각 색상은 특정 이벤트 유형, 커맨드, 정책 등을 나타내는데 사용됩니다.

3. **참가자의 역할 정의 (도메인 전문가, 개발자, 이해관계자 등)**
각 참가자는 자신의 역할에 따라 도메인 이벤트를 제안하고, 도메인 모델링을 수행합니다. 도메인 전문가는 비즈니스 규칙을 설명하고, 개발자는 이를 기술적으로 구현 가능한 형태로 전환하는 역할을 합니다.
    </mark-down>
    <g-image src="https://github.com/user-attachments/assets/8ab4e2b5-c7e6-4d13-9e24-86ac192d916b"></g-image>

    <mark-down  class="content">

### 이벤트스토밍 세션:

이벤트스토밍은 도메인의 전체적인 구조와 흐름을 이해하는 '빅픽처 이벤트스토밍', 도메인의 이벤트들을 더 세부적으로 분석하고 비즈니스 프로세스를 모델링하는 '프로세스 모델링', 이벤트스토밍에서 도출된 결과를 바탕으로 실제 소프트웨어 아키텍처를 설계하는 '소프트웨어 디자인'의 3 단계로 구성됩니다. 이 3 단계는 순차적으로 진행되지만 필요에 따라 반복적으로 수행될 수 있으며, 각 단계의 결과물은 다음 단계의 입력으로 사용됩니다. 이러한 과정을 통해 비즈니스 요구사항부터 실제 소프트웨어 구현까지 일관된 흐름으로 설계할 수 있습니다.
    </mark-down>
    <g-image src="https://github.com/user-attachments/assets/5b49ce03-6966-4179-8743-cc940b0d1c15"></g-image>

    <mark-down class="content">
### 1. 빅 픽처(Big Picture) 이벤트스토밍 단계 ###
빅 픽처 이벤트스토밍은 이벤트스토밍의 첫 번째 단계로, 도메인의 전체적인 구조와 흐름을 이해하는 단계입니다. 팀 전체가 도메인에 대한 공통된 이해를 목표로 전체 도메인에 대한 큰 그림을 스케치 합니다. 이 단계에서는 주요 도메인 이벤트를 식별하고, 이를 시간 순으로 배열하며, 관련된 액터, 커맨드, 시스템, 정책 등을 다음 단계에서 이어서 추가합니다. 

#### 주요 활동: ####

- **도메인 이벤트 식별**: 이 단계에서는 비즈니스에서 발생하는 중요한 사건(이벤트)을 포스트잇에 적어 벽에 붙입니다. 도메인 이벤트는 "주문 생성됨", "결제 완료됨", "배송 시작됨" 등과 같이 **과거 시제**로 정의하며, 이는 도메인 내에서 발생한 상태 변화를 나타냅니다. 여기서 상태 변화란 새로운 주문의 생성, 기존 주문의 수정, 주문 취소 등 데이터의 성질이 변화한 결과를 의미합니다. 반면, "주문 선택됨", "주문 검색됨"과 같은 이벤트들은 도메인 내부 상태의 변화를 반영하지 않으므로, 이벤트 후보에서 제외해야 합니다. 이러한 이벤트는 시각적 구분을 위해 포스트잇을 비스듬히 기울여 부착합니다. 도메인 이벤트는 일반적으로 시간 순서에 따라 왼쪽에서 오른쪽, 위에서 아래로 배열합니다.

- **참여자 간의 협력**: 이벤트스토밍은 한 스프린트당 약 2시간씩 여러 스프린트에 걸쳐 진행되며, 개발자, 도메인 전문가, 비즈니스 이해관계자 등 다양한 참여자들이 함께 협력하여 이벤트를 도출합니다. 각 참여자는 자신의 관점에서 중요한 이벤트를 제안하고, 이를 다른 참여자들과 논의하며 도메인에 대한 이해를 공유합니다.

- **이벤트 간의 인과 관계 정의**: 이벤트들이 발생하는 순서와 인과 관계를 시각적으로 표현합니다. 이를 통해 전체 도메인의 흐름을 이해하고, 어떤 이벤트가 어떤 결과를 초래하는지 파악할 수 있습니다.
    </mark-down>
    <g-image src="https://github.com/user-attachments/assets/08d0d133-4694-4c6a-8638-dbb4a9b09d05"></g-image>
    <mark-down class="content">
<'빅 픽처(Big Picture) 이벤트스토밍' 결과물 예시>

### 2. 프로세스 모델링(Process Modeling) 단계 ###
프로세스 모델링 단계는 빅 픽처에서 식별된 핵심 프로세스를 선택하여 더 상세히 분석하고 프로세스를 모델링합니다. 선택한 프로세스의 모든 이벤트를 시간 순으로 나열하고, 각 이벤트와 관련된 커맨드, 액터, 시스템, 정책, 데이터 요구사항, 비즈니스 규칙 등을 추가합니다. 이 과정에서 프로세스의 문제점과 개선 기회도 함께 식별합니다.

#### 주요 활동: ####

- **커맨드와 액터 식별**: 각 이벤트를 유발하는 커맨드(명령)와 이를 수행하는 액터(사용자 또는 시스템)를 식별합니다. 예를 들어, "주문 생성됨" 이벤트는 "주문 요청" 커맨드에 의해 트리거될 수 있습니다. 다시 말해, 커맨드는 이벤트를 발생시키는 명령을 의미하며, 이벤트 포스트잇의 왼쪽에 위치시킵니다. 이러한 커맨드를 실행하는 주체를 '액터'라고 하며, 액터는 커맨드를 수행하는 사용자(고객)나 시스템을 포함합니다. 일부 명령은 시스템이나 정책에 의해 자동으로 실행될 수 있으므로, 시스템 액터를 생략하지 않고 사용자 액터처럼 명시적으로 표현하는 것이 일반적입니다.

- **정책 및 규칙 추가**: 한 이벤트가 발생하면, 다른 커맨드가 연이어 수행되어야 하는 경우가 있습니다. 이러한 흐름을 '정책'이라고 하며, 보통 "Whenever 도메인 이벤트, then ~한다."와 같은 형식으로 해석됩니다. 예를 들어, "주문이 완료되면, 배송 업무가 시작된다." 또는 "주문이 취소되면, 상품 재고가 증가한다."와 같은 업무 흐름이 이에 해당합니다. 정책에는 도메인 규칙을 포함됩니다. 예를 들어, "주문 결제가 완료되면, 온라인 판매처의 경우, 온라인 벤더 시스템에 주문 생성을 요청하고, 오프라인 판매처의 경우, 주문 상태를 접수로 변경한다."와 같은 규칙 적용이 가능합니다.

- **외부 시스템 연계**: 액터가 내린 커맨드가 실행되면, 우리가 개발하는 시스템 또는 외부 시스템과 상호 작용하여 동작합니다. 외부 시스템이란 예를 들어, 상품 대금 결제를 처리하는 결제 회사나 물류 위탁을 위한 배송 업체와 같은 서비스를 말합니다. 서브 도메인을 유형에 따라 핵심(Core), 지원(Supportive), 일반(Generic) 도메인으로 분류할 때, 일반 도메인이 주로 이러한 외부 시스템에 해당됩니다.

- **바운디드 컨텍스트 경계 식별**: 바운디드 컨텍스트는 특정 도메인 모델이 적용되는 경계를 의미합니다. 프로세스 모델링 단계에서 대략적인 경계를 설정하고, 이후 단계에서 이를 더 명확히 설정하고 필요에 따라 조정하는 것이 일반적인 접근 방식입니다.

- **워크플로우 정의**: 이벤트 간의 흐름을 구체적으로 정의하여 비즈니스 프로세스가 어떻게 진행되는지 시각화합니다. 이를 통해 프로세스의 병목 현상이나 최적화할 부분을 발견할 수 있습니다.
    </mark-down>
    <g-image src="https://github.com/user-attachments/assets/cdfdd6d7-bc10-4a27-a345-ae33725bd6e1"></g-image>
    <mark-down class="content">
<'프로세스 모델링(Process Modeling)' 결과물 예시>

### 3. 소프트웨어 디자인(Software Design) 단계 ###
소프트웨어 디자인 단계는 앞선 두 단계의 결과를 바탕으로 실제 소프트웨어 구현을 위한 상세 설계를 진행합니다. 시스템의 주요 컴포넌트를 식별하고, 데이터 모델과 API를 설계합니다. 또한 적합한 기술 스택을 선택하고, CQRS와 같은 아키텍처 패턴을 적용하며, 테스트 전략과 배포 및 운영 계획을 수립합니다.

#### 주요 활동: ####

- **애그리거트(Aggregate) 정의**: 애그리거트(Aggregate)는 도메인 내에서 일관성을 유지하고, 연관된 객체들을 하나의 단위로 그룹화한 것입니다. 애그리거트는 도메인 상태를 변경하는 명령(Command)을 처리하며, 그 결과로 도메인 이벤트를 발생시킵니다. 애그리거트의 주요 역할은 **트랜잭션 경계를 설정**하고, 하나의 트랜잭션으로 일관성을 보장해야 하는 상태 변경 범위를 정의하는 것입니다. 즉, 애그리거트는 도메인 내에서 "무엇"이 명령을 처리하고, 변경된 상태를 하나의 트랜잭션으로 데이터베이스에 커밋하는지 결정합니다. 애그리거트는 **도메인 모델 설계의 중요한 요소**로, 구현과 밀접하게 연관되어 있습니다. 따라서 애그리거트의 정의는 도메인 전문가뿐만 아니라 개발자들이 주도하여 설계하는 것이 중요합니다. 이를 통해 애그리거트는 비즈니스 로직과 기술적 구현 간의 일관성을 유지할 수 있습니다.

- **애그리거트 상세 설계 및 연동**: 이벤트스토밍에서 도출된 데이터를 기반으로 도메인 상태 저장소를 설계하고, 시스템이 데이터를 어떻게 저장하고 관리할지 결정합니다.
    - 애기리거트 상세 설계에 대한 내용은 도메인 주도 설계(메뉴 링크) 메뉴 참조

- **바운디드 컨텍스트(Bounded Context) 확정**: 프로세스 모델링 단계에서 식별된 도메인 경계를 확정하여 각각의 컨텍스트가 독립적인 도메인 모델을 가지도록 설계합니다. 각 컨텍스트 간의 상호작용 방식(컨텍스트 매핑)도 이 단계에서 정의됩니다.

- **코드 구조 설계**: 도메인 모델을 실제 코드로 구현하기 위한 구조(프레임워크 템플릿)를 설계합니다. 이 단계에서는 엔티티, 밸류 객체, 인터페이스, 데이터베이스 스키마 등 기술적인 설계가 포함됩니다.

- **리드 모델(Read Model) 설계**: 데이터 수집 모델(Command Model)이 도메인 상태 변경, 비즈니스 로직 실행, 이벤트 발생 등을 처리하는 역할을 한다면, 리드 모델(Query Model)은 사용자 화면에 표시할 데이터를 질의(Query)를 통해 읽어 오는 역할을 담당합니다. 리드 모델은 데이터를 효율적으로 조회할 수 있도록 최적화되어 있으며, 데이터 수집 모델에서 발생한 도메인 이벤트를 기반으로 갱신됩니다. 리드 모델에는 단일 애그리거트를 조회하는 모델뿐만 아니라, 여러 바운디드 컨텍스트 내의 애그리거트에서 조합된 데이터를 조회하는 모델도 포함됩니다. 두 모델 모두 도메인 이벤트에 의해 갱신된 저장소에서 데이터를 가져와 사용자에게 전달됩니다. 이러한 명령(Command)과 질의(Query) 책임을 분리하는 패턴을 CQRS(Command Query Responsibility Segregation, 명령-질의 책임 분리) 아키텍처 패턴이라고 하며, 이 패턴은 일종의 머티어리얼라이즈드 뷰(Materialized View) 형태로 구현됩니다.

- **Given-When-Then 패턴 기반 이벤트 중심 테스트 설계**: 도메인 이벤트를 기반으로 테스트 케이스를 정의하여, 도메인이 요구하는 비즈니스 로직이 제대로 구현되었는지 검증할 수 있도록 합니다. Given-When-Then 패턴을 활용하면, 도메인의 요구사항을 정확히 반영한 테스트를 작성할 수 있습니다. 특히, 애그리거트(Aggregate), 커맨드(Command), 도메인 이벤트(Domain Event)의 관계를 중심으로 테스트를 구성하면, 도메인 로직이 올바르게 구현되었는지 효과적으로 검증할 수 있습니다.
    - **Given 단계**는 테스트의 초기 상태를 설정하는 부분입니다. 여기서는 애그리거트의 초기 상태를 정의합니다. 애그리거트는 도메인 내에서 상태를 유지하고, 커맨드에 따라 상태를 변경하는 역할을 하므로, 이 초기 상태가 테스트의 출발점이 됩니다.
    - **When 단계**는 테스트에서 수행할 커맨드를 실행하는 부분입니다. 커맨드는 도메인 이벤트를 유발하는 명령으로, 애그리거트 상에서 특정 비즈니스 로직을 실행하는 명령을 테스트합니다.
    - **Then 단계**에서는 도메인 이벤트가 예상대로 발생했는지를 검증합니다. 커맨드를 실행한 결과로, 애그리거트가 도메인의 상태를 변경했음을 나타내는 도메인 이벤트가 발생해야 합니다. 이 이벤트는 비즈니스 로직이 제대로 수행되었음을 나타내는 결과물입니다.
    - 예시 : 상품 재고가 10개인 상태(Given)에서 5개의 재고가 차감(When)되면, 재고가 5개로 줄어드는 '재고차감됨' 도메인 이벤트가 발생(Then)합니다.
    </mark-down>
    <g-image src="https://github.com/user-attachments/assets/89383563-86ea-47a2-8f8c-2c5b77581293"></g-image>
    <mark-down class="content">
<'소프트웨어 디자인' 결과물 예시>
    </mark-down>
    <g-image src="https://github.com/user-attachments/assets/203a4489-30f6-4102-8fd4-88d039051859"></g-image>
    <mark-down class="content">
<'CQRS': Mypage 리드 모델 설계 예시>
    </mark-down>
    <g-image src="https://github.com/user-attachments/assets/f39c8bd5-c256-4bcb-9c46-0b2137ac06c1"></g-image>
    <mark-down class="content">
<'모델 기반 Given-When-Then' 테스트 예시: 10개 재고에서 2개 주문 시, 8개 재고가 도메인 이벤트로 출력>

### 이벤트스토밍에서 바운디드 컨텍스트와 컨텍스트 매핑:

바운디드 컨텍스트(확정된 도메인 경계) 도출과 컨텍스트 매핑(각 컨텍스트 간의 상호작용 방식)은 이벤트스토밍의 중요한 결과물 중 하나로, 이를 통해 복잡한 도메인을 관리 가능한 단위로 나누고, 각 단위 간의 관계를 명확히 하여 시스템 설계와 개발에 큰 가이드라인을 제시합니다. 이벤트스토밍 과정에서 도출된 도메인 이벤트들을 분석하여, 관련성이 높은 이벤트들을 그룹화해 바운디드 컨텍스트를 식별합니다. 예를 들어, "주문 생성됨", "결제 완료됨"와 같은 이벤트들이 주문 관리 바운디드 컨텍스트로 묶일 수 있습니다.

### 1. 바운디드 컨텍스트를 다시 정리해 보면,

바운디드 컨텍스트(Bounded Context)는 DDD에서 도메인을 논리적으로 분리하여, 각 부분이 독립적인 경계를 가지는 영역을 의미합니다. 이 개념은 도메인의 복잡성을 줄이기 위해 도메인을 여러 개의 작은 컨텍스트로 나누는 것을 목표로 합니다. 각 바운디드 컨텍스트는 자체적인 도메인 모델을 가지고 있으며, 다른 컨텍스트와는 명확하게 구분됩니다.

#### 바운디드 컨텍스트의 특징: ####

- **독립적인 모델**: 각 바운디드 컨텍스트는 고유한 도메인 모델을 가지며, 동일한 개념이라도 다른 컨텍스트에서는 다르게 해석될 수 있습니다. 예를 들어, "주문"이라는 개념이 주문 관리 시스템과 고객 서비스 시스템에서 다른 의미를 가질 수 있습니다.
- **명확한 경계**: 바운디드 컨텍스트 간의 경계는 명확해야 하며, 이 경계를 통해 각 컨텍스트는 독립적으로 발전하고 변경될 수 있습니다. 경계를 명확히 정의하면 시스템의 복잡성을 줄이고, 팀 간의 협업을 더 원활하게 할 수 있습니다.
- **팀 구조와 연계**: 바운디드 컨텍스트는 종종 팀 구조와 연계됩니다. 예를 들어, 특정 바운디드 컨텍스트는 특정 팀이 책임지고 개발하며, 다른 팀과는 명확한 인터페이스를 통해 상호작용합니다.

#### 바운디드 컨텍스트의 중요성: ####

- **모델 일관성**: 바운디드 컨텍스트를 정의함으로써, 각 컨텍스트 내에서는 일관된 도메인 모델을 유지할 수 있습니다. 이는 복잡한 도메인에서 모델의 혼란을 줄이고, 코드베이스의 유지보수를 쉽게 만듭니다.
- **변경의 용이성**: 한 컨텍스트에서의 변경이 다른 컨텍스트에 영향을 미치지 않도록 하여, 시스템의 특정 부분만 변경할 수 있는 유연성을 제공합니다.
- **개발의 독립성**: 여러 팀이 동시에 독립적으로 개발할 수 있도록 돕습니다. 각 팀은 자신이 담당하는 바운디드 컨텍스트 내에서 작업하며, 다른 팀과의 의존성을 줄일 수 있습니다.

### 2. 컨텍스트 매핑(Context Mapping) 이란?

컨텍스트 매핑(Context Mapping)은 여러 바운디드 컨텍스트 간의 관계를 정의하고, 이들이 어떻게 상호작용하는지 시각화하는 과정입니다. 복잡한 시스템에서는 여러 바운디드 컨텍스트가 존재하며, 이들 간의 상호작용이 복잡해질 수 있습니다. 컨텍스트 매핑은 이러한 상호작용을 명확하게 파악하고, 시스템 전반의 구조를 이해하는 데 도움을 줍니다. 이벤트스토밍에서 도출된 바운디드 컨텍스트 간의 상호작용을 정의하고, 이를 시각화하는 작업이 컨텍스트 매핑입니다. 이 단계에서 각 컨텍스트 간의 관계를 패턴(예: 고객-공급자, 공유 커널 등)에 따라 정의합니다. 예를 들어, 주문 관리 컨텍스트가 재고 관리 컨텍스트와 고객-공급자 관계를 가질 수 있습니다.

#### 컨텍스트 매핑의 주요 패턴: ####

- **공유 커널(Shared Kernel)**: 두 컨텍스트가 공통의 모델을 공유합니다. 예를 들어, 핵심적인 데이터 모델을 공유하여 일관성을 유지하지만, 다른 부분에서는 독립적으로 동작합니다. 이 패턴은 종종 서로의 모델을 함께 관리하는 두 팀 간의 협력을 요구합니다.

- **고객-공급자(Customer-Supplier)**: 한 컨텍스트(공급자)가 다른 컨텍스트(고객)에게 서비스를 제공하는 관계입니다. 공급자는 고객의 요구사항에 맞추어 모델을 설계하고, 고객은 공급자의 모델을 활용합니다. 이 패턴에서는 공급자의 모델이 고객의 요구를 충족하는 것이 중요합니다.

- **번역 계층(Anti-corruption Layer)**: 한 컨텍스트가 다른 컨텍스트와 상호작용할 때, 두 모델 간의 불일치를 해결하기 위해 변환 계층(번역 계층)을 추가하는 패턴입니다. 이를 통해 두 컨텍스트 간의 상호작용을 원활하게 하며, 서로의 모델 변경에 대한 영향을 최소화할 수 있습니다.

- **공개 호스트 서비스(Open Host Service)**: 통합 검색 서비스처럼 각 다운스트림 컨텍스트별로 구현하기 보다는 여러 종류의 다운스트림 컨텍스트를 위해 업스트림 컨텍스트에서 접근 프로토콜이나 인터페이스(공유된 API)를 제공합니다.

이벤트스토밍은 복잡한 도메인을 시각화하고 이해하는 데 매우 효과적인 도구이며, 바운디드 컨텍스트와 컨텍스트 매핑을 통해 도메인의 복잡성을 관리할 수 있습니다. 바운디드 컨텍스트는 도메인을 논리적으로 분리하고, 컨텍스트 매핑은 이러한 분리된 컨텍스트 간의 관계를 명확히 하여 시스템을 효과적으로 설계하는 데 기여합니다.
    </mark-down>
    <g-image src="https://github.com/user-attachments/assets/e0d18273-e581-4bbd-aa50-3ed51d68216b"></g-image>
    <mark-down class="content">
<'12st Mall' 컨텍스트 매핑 예시>

### 이벤트스토밍 적용 예시: 

### 1. 산재신청(Application for industrial accident compensation)

#### 기능적 요구사항 ####
- 근로자가 요양급여 신청서를 작성하여 제출한다.
- 병원은 의사의 소견서와 요양 병원 직인을 신청서에 첨부하고, 공단에 대행 신청한다.
- 사업주는 근로복지공단을 통해 산재 신청 사실을 통보 받는다.
- 근로복지공단은 질병의 인과관계 확인을 위해 현장조사와 특별 진찰을 수행한다.
- 인과관계가 확인되면, 근로복지공단은 접수된 신청을 승인한다.
- 승인을 통보 받은 근로자는 휴업 급여를 청구한다.
- 불승인된 경우, 근로자는 심사청구를 요청할 수 있다.
- 근로복지공단은 해당 사업장에 근로자의 평균 임금을 요청한다.
- 근로복지공단은 심사결과와 보상 금액을 근로자에게 통보한다.
- 심사결과 금액에 불복하는 근로자는 재심사를 청구할 수 있다.
- 근로자가 요양급여 지급 확인원(증명서) 발급을 요청한다. 
### 비기능적 요구사항 ####

- **장애격리 **
    - 요양급여 처리 서비스 장애 시에도 요양급여 신청 접수는 문제가 없어야 한다. Event-driven, Eventual Consistency
    - 일부 시스템이 과중 되면 적절히 확장이 이루어져야 한다. Horizontal Auto Scale
- **프로세스 준수 **
    - 각 마이크로 서비스를 넘나드는 프로세스는 일관성이 있게 준수되어야 한다. (예: 업무상 재해가 명확한 경우 7일 이내 요양승인 여부가 결정된다.)
- **성능 **
    - 근로자 보수총액 신고 기간(매년 3월 말까지) 및 근로자가 자주 민원 진행 상태를 조회하더라도 성능저하가 없어야 한다.  Auto Scale Out, CQRS
- **도메인 제약사항**
    - 산재 신청은 4일 이상 요양이 필요한 질병에 대해 산재신청이 가능하다.
    - 휴업 급여는 평균 임금의 70%로 산정한다.
</mark-down>
    <g-image src="https://github.com/user-attachments/assets/5ede8bb3-1b92-4c99-a049-b4b0d8095930"></g-image>
<mark-down class="content">
### 2. 음식배달 앱(Food Delivery Application)

#### 기능적 요구사항 ####

- 고객이 메뉴를 선택하고, 선택한 메뉴에 대해 결제함으로써 주문이 발생한다.
- 주문이 되면 입점 상점주에게 주문정보가 전달된다.
- 상점주는 주문을 수락하거나 거절할 수 있다.
- 상점주는 요리 시작시와 완료 시점에 시스템에 상태를 입력한다.
- 고객은 아직 요리가 시작되지 않은 주문을 취소할 수 있다.
- 요리가 시작되면 고객 지역 인근의 라이더들에 배송정보가 전달된다.
- 라이더가 해당 요리를 Pick한 후, 출발전 앱에 등록하면 배송시작 정보가 앱을 통해 고객에게 통보된다.
- 고객은 주문상태를 중간중간 조회한다.
- 시스템은 주문상태가 바뀔 때 마다 카톡으로 알림을 발송한다.
- 라이더가 요리를 전달한뒤 배송확인 버튼을 탭하여, 모든 거래가 완료된다.

### 비기능적 요구사항 ####

- **장애격리 **
    - 상점관리 기능이 수행되지 않더라도 주문은 365일 24시간 받을 수 있어야 한다 Async (event-driven), Eventual Consistency
    - 결제시스템이 과중되면 사용자를 잠시동안 받지 않고 결제를 잠시후에 하도록 유도한다 Circuit breaker, fallback    
- **모니터링 **
    - 고객이 자주 상점관리에서 확인할 수 있는 배달상태를 주문시스템(프론트엔드)에서 확인할 수 있어야 한다 CQRS
    - 배달상태가 바뀔때마다 카톡 등으로 알림을 줄 수 있어야 한다 Event driven
</mark-down>
    <g-image src="https://github.com/user-attachments/assets/5ede8bb3-1b92-4c99-a049-b4b0d8095930"></g-image>
    </div>
</template>


<script>
        // @group 02_02_04
    export default {
        name: 'DesignThree',
        props: {
            "이벤트스토밍": {
                type: String
            },
        },

    }
</script>
<style>
.text .h3 {
    margin-bottom: -20px;
}
</style>